import{DepGraph as e}from"dependency-graph";import{pointerToPath as t,trimStart as r,pathToPointer as s,startsWith as i}from"@stoplight/json";import{join as o,dirname as n,stripRoot as h,toFSPath as a}from"@stoplight/path";import c,{original as l}from"immer";import{get as u,set as f}from"lodash";import*as p from"urijs";class d{constructor(e={}){this._stats={hits:0,misses:0},this._data={},this._stdTTL=e.stdTTL}get stats(){return this._stats}get(e){const t=this._data[e];if(t&&(!this._stdTTL||(new Date).getTime()-t.ts<this._stdTTL))return this._stats.hits+=1,t.val;this._stats.misses+=1}set(e,t){this._data[e]={ts:(new Date).getTime(),val:t}}has(e){return e in this._data}}function g(e,t,r,s){return new(r||(r=Promise))(function(i,o){function n(e){try{a(s.next(e))}catch(e){o(e)}}function h(e){try{a(s.throw(e))}catch(e){o(e)}}function a(e){e.done?i(e.value):new r(function(t){t(e.value)}).then(n,h)}a((s=s.apply(e,t||[])).next())})}const m=(e,t,r)=>{const s=e.toString();let i="",o=s,n=0,h=o.indexOf(t);for(;h>-1;)i+=s.substring(n,n+h)+r,o=o.substring(h+t.length,o.length),n+=h+t.length,h=o.indexOf(t);return o.length>0&&(i+=s.substring(s.length-o.length,s.length)),i},v=(e,t)=>`${e}/${(e=>m(m(e,"~","~0"),"/","~1"))(t)}`,R=e=>e&&e.fragment()?`#${e.fragment()}`:"",S=e=>"#/"===e.toString().slice(0,2);class _{constructor(r,s){this.resolvers=[],this.pointerGraph=new e({circular:!0}),this.pointerStemGraph=new e({circular:!0}),this.computeGraph=((e,t=[],r="#",s=[])=>{r||(r="#");let i=this._runner.computeRef({val:e,jsonPointer:r,pointerStack:s});if(i)this._resolveRef({ref:i,val:e,parentPath:t,pointerStack:s,parentPointer:r,cacheKey:r,resolvingPointer:this.jsonPointer});else if("object"==typeof e)for(const o in e){if(!e.hasOwnProperty(o))continue;const n=e[o],h=v(r,o);i=this._runner.computeRef({key:o,val:n,jsonPointer:h,pointerStack:s}),t.push(o),i?this._resolveRef({ref:i,val:n,parentPath:t,parentPointer:h,pointerStack:s,cacheKey:R(i),resolvingPointer:this.jsonPointer}):"object"==typeof n&&this.computeGraph(n,t,h,s),t.pop()}}),this._resolveRef=(e=>{const{pointerStack:r,parentPath:s,parentPointer:i,ref:o}=e;if(S(o)){if(this._runner.dereferenceInline){const e=R(o),n=t(e);let h=!0;for(const e in n)if(s[e]!==n[e]){h=!1;break}if(h)return;this.pointerStemGraph.hasNode(e)||this.pointerStemGraph.addNode(e);let a="#",c="";for(let t=0;t<s.length;t++){const r=s[t];if(r===n[t])a+=`/${r}`;else{const t=`${a}${c+=`/${r}`}`;t!==i&&t!==e&&(this.pointerStemGraph.hasNode(t)||this.pointerStemGraph.addNode(t),this.pointerStemGraph.addDependency(t,e))}}this.pointerGraph.hasNode(i)||this.pointerGraph.addNode(i),this.pointerGraph.hasNode(e)||this.pointerGraph.addNode(e);const l=`${this._runner.baseUri.toString()}${e}`;this._runner.graph.hasNode(l)||this._runner.graph.addNode(l,{refMap:{}}),this._runner.root!==l&&this._runner.graph.addDependency(this._runner.root,l),this.pointerGraph.addDependency(i,e),this.jsonPointer&&(r.push(e),this.computeGraph(u(this._runner.source,n),n,e,r),r.pop())}}else{const t=o.toString();this._runner.graph.hasNode(t)||this._runner.graph.addNode(t,{refMap:{}}),this._runner.root!==t&&this._runner.graph.addDependency(this._runner.root,t),this._runner.dereferenceRemote&&!this._runner.atMaxUriDepth()&&this.resolvers.push(this._runner.lookupAndResolveUri(e))}}),this.jsonPointer=s,this._runner=r}}const y=require("fast-memoize");let b=0;const k=(e,t)=>{if(t&&"object"==typeof t&&"string"==typeof t.$ref)return t.$ref};class N{constructor(t,s=new e({circular:!0}),i={}){this.ctx={},this.computeRef=(e=>{const t=this.getRef(e.key,e.val);if(!t)return;let r=new p(t);if("#"!==r.toString().charAt(0)){if(this.isFile(r)){let e=r.toString();r.is("absolute")||(e=this.baseUri.toString()?o(n(this.baseUri.toString()),h(e)):""),e&&(r=new p(a(e)).fragment(r.fragment()))}else(r.scheme().includes("http")||""===r.scheme()&&this.baseUri.scheme().includes("http"))&&""!==this.baseUri.authority()&&""===r.authority()&&(r=r.absoluteTo(this.baseUri))}return this.transformRef?this.transformRef(Object.assign(Object.assign({},e),{ref:r,uri:this.baseUri}),this.ctx):r}),this.atMaxUriDepth=(()=>this.uriStack.length>=100),this.lookupUri=(e=>g(this,void 0,void 0,function*(){const{ref:t}=e;let r=t.scheme();!this.resolvers[r]&&this.isFile(t)&&(r="file");const s=this.resolvers[r];if(!s)throw new Error(`No resolver defined for scheme '${t.scheme()||"file"}' in ref ${t.toString()}`);let i=yield s.resolve(t,this.ctx);if(this.parseResolveResult)try{i=(yield this.parseResolveResult({uriResult:i,result:i,targetAuthority:t,parentAuthority:this.baseUri,parentPath:e.parentPath,fragment:e.fragment})).result}catch(e){throw new Error(`Could not parse remote reference response for '${t.toString()}' - ${String(e)}`)}return new N(i,this.graph,{depth:this.depth+1,baseUri:t.toString(),root:t,uriStack:this.uriStack,uriCache:this.uriCache,resolvers:this.resolvers,transformRef:this.transformRef,parseResolveResult:this.parseResolveResult,transformDereferenceResult:this.transformDereferenceResult,dereferenceRemote:this.dereferenceRemote,dereferenceInline:this.dereferenceInline,ctx:this.ctx})})),this.lookupAndResolveUri=(e=>g(this,void 0,void 0,function*(){const{val:t,ref:s,resolvingPointer:i,parentPointer:o,pointerStack:n}=e,h=(e.parentPath||[]).slice(),a=this.computeUriCacheKey(s),c={uri:s,pointerStack:n,targetPath:i===o?[]:h};if(this.uriStack.includes(a))return c.resolved={result:t,graph:this.graph,refMap:{},errors:[],runner:this},c;{let e;try{if(this.atMaxUriDepth())throw new Error(`Max uri depth (${this.uriStack.length}) reached. Halting, this is probably a circular loop.`);e=yield this.lookupUri({ref:s.clone().fragment(""),fragment:s.fragment(),cacheKey:a,parentPath:h});const t=this.baseUri.toString();t&&0!==this.depth&&(e.uriStack=e.uriStack.concat([t]))}catch(e){c.error={code:"RESOLVE_URI",message:String(e),uri:s,uriStack:this.uriStack,pointerStack:n,path:h}}if(e&&(c.resolved=yield e.resolve({jsonPointer:R(s),parentPath:h}),c.resolved.errors.length))for(const e of c.resolved.errors)if("POINTER_MISSING"===e.code&&e.path.join("/")===s.fragment().slice(1)){const i=s.fragment?r(e.path,r(s.fragment(),"/").split("/")):e.path;i&&i.length?f(c.resolved.result,i,t):c.resolved.result&&(c.resolved.result=t)}}return c})),this.id=b+=1,this.depth=i.depth||0,this._source=t,this.resolvers=i.resolvers||{};const c=i.baseUri||"";let l=new p(c||"");this.isFile(l)&&(l=new p(a(c))),this.baseUri=l,this.uriStack=i.uriStack||[],this.uriCache=i.uriCache||new d,this.root=i.root&&i.root.toString()||this.baseUri.toString()||"root",this.graph=s,this.graph.hasNode(this.root)||this.graph.addNode(this.root,{refMap:{},data:this._source}),this.baseUri&&0===this.depth&&this.uriCache.set(this.computeUriCacheKey(this.baseUri),this),this.getRef=i.getRef||k,this.transformRef=i.transformRef,this.depth?this.dereferenceInline=!0:this.dereferenceInline=void 0===i.dereferenceInline||i.dereferenceInline,this.dereferenceRemote=void 0===i.dereferenceRemote||i.dereferenceRemote,this.parseResolveResult=i.parseResolveResult,this.transformDereferenceResult=i.transformDereferenceResult,this.ctx=i.ctx,this.lookupUri=y(this.lookupUri,{serializer:this._cacheKeySerializer,cache:{create:()=>this.uriCache}})}get source(){return this._source}resolve(e){return g(this,void 0,void 0,function*(){const r={result:this.source,graph:this.graph,refMap:{},errors:[],runner:this};let o;const n=e&&e.jsonPointer&&e.jsonPointer.trim();if(n&&"#"!==n&&"#/"!==n&&(o=t(n),r.result=u(r.result,o)),void 0===r.result)return r.errors.push({code:"POINTER_MISSING",message:`'${n}' does not exist @ '${this.baseUri.toString()}'`,uri:this.baseUri,uriStack:this.uriStack,pointerStack:[],path:o||[]}),r;const h=new _(this,n);h.computeGraph(r.result,o,n||"");let a=[];if(h.resolvers.length&&(a=yield Promise.all(h.resolvers)),a.length)for(const e of a){let t=e.targetPath;t.length||(t=o||[]),r.refMap[String(this.baseUri.clone().fragment(s(t)))]=String(e.uri),this._setGraphNodeEdge(String(this.root),s(t),String(e.uri)),e.error&&r.errors.push(e.error),e.resolved&&(e.resolved.errors&&(r.errors=r.errors.concat(e.resolved.errors)),void 0!==e.resolved.result&&(this._source=c(this._source,r=>{if(e.resolved){if(!t.length)return e.resolved.result;f(r,t,e.resolved.result),this._setGraphNodeData(String(e.uri),e.resolved.result)}})))}if("object"==typeof this._source?(this.dereferenceInline&&(this._source=c(this._source,e=>{let o=[];try{o=h.pointerGraph.overallOrder();for(const n of o){const o=h.pointerGraph.dependantsOf(n);if(!o.length)continue;const a=t(n),c=u(e,a);for(const u of o){let o;const p=t(u),d=h.pointerStemGraph.dependenciesOf(n);for(const e of d)if(i(p,t(e))){o=!0;break}o||(r.refMap[s(p)]=s(a),this._setGraphNodeEdge(this.root,s(p),s(a)),void 0!==c?(f(e,p,c),this._setGraphNodeData(s(a),l(c))):r.errors.push({code:"POINTER_MISSING",message:`'${n}' does not exist`,path:p,uri:this.baseUri,uriStack:this.uriStack,pointerStack:[]}))}}}catch(e){}})),r.result=o?u(this._source,o):this._source):r.result=this._source,this.transformDereferenceResult){const t=new p(n||"");try{const{result:s,error:i}=yield this.transformDereferenceResult({source:this.source,result:r.result,targetAuthority:t,parentAuthority:this.baseUri,parentPath:e&&e.parentPath||[],fragment:t.fragment()});if(r.result=s,i)throw new Error(`Could not transform dereferenced result for '${t.toString()}' - ${String(i)}`)}catch(e){r.errors.push({code:"TRANSFORM_DEREFERENCED",message:`Error: Could not transform dereferenced result for '${this.baseUri.toString()}${""!==t.fragment()?`#${t.fragment()}`:""}' - ${String(e)}`,uri:t,uriStack:this.uriStack,pointerStack:[],path:o})}}return this._setGraphNodeData(this.root,this._source),r})}_cacheKeySerializer(e){return e&&"object"==typeof e&&e.cacheKey?e.cacheKey:JSON.stringify(arguments)}computeUriCacheKey(e){return e.clone().fragment("").toString()}isFile(e){const t=e.scheme();if("file"===t)return!0;if(t){if(!this.resolvers[t])return!0}else{if("/"===e.toString().charAt(0))return!0;if(this.baseUri){const e=this.baseUri.scheme();return Boolean(!e||"file"===e||!this.resolvers[e])}}return!1}_setGraphNodeData(e,t){if(!this.graph.hasNode(e))return;const r=this.graph.getNodeData(e)||{};r.data=t,this.graph.setNodeData(e,r)}_setGraphNodeEdge(e,t,r){if(!this.graph.hasNode(e))return;const s=this.graph.getNodeData(e)||{};s.refMap=s.refMap||{},s.refMap[t]=r,this.graph.setNodeData(e,s)}}class U{constructor(e={}){this.ctx={},this.uriCache=e.uriCache||new d,this.resolvers=e.resolvers||{},this.getRef=e.getRef,this.transformRef=e.transformRef,this.dereferenceInline=void 0===e.dereferenceInline||e.dereferenceInline,this.dereferenceRemote=void 0===e.dereferenceRemote||e.dereferenceRemote,this.parseResolveResult=e.parseResolveResult,this.transformDereferenceResult=e.transformDereferenceResult,this.ctx=e.ctx}resolve(t,r={}){const s=new e({circular:!0});return new N(t,s,Object.assign(Object.assign({uriCache:this.uriCache,resolvers:this.resolvers,getRef:this.getRef,transformRef:this.transformRef,dereferenceInline:this.dereferenceInline,dereferenceRemote:this.dereferenceRemote,parseResolveResult:this.parseResolveResult,transformDereferenceResult:this.transformDereferenceResult},r),{ctx:Object.assign({},this.ctx||{},r.ctx||{})})).resolve(r)}}export{d as Cache,U as Resolver,k as defaultGetRef};
