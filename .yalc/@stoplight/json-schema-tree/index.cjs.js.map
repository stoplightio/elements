{"version":3,"file":"index.cjs.js","sources":["../src/nodes/BaseNode.ts","../src/nodes/mirrored/MirroredReferenceNode.ts","../src/utils/guards.ts","../src/utils/pick.ts","../src/nodes/mirrored/MirroredRegularNode.ts","../src/accessors/unwrap.ts","../src/nodes/ReferenceNode.ts","../src/accessors/getAnnotations.ts","../src/nodes/types.ts","../src/accessors/getCombiners.ts","../src/accessors/getPrimaryType.ts","../src/accessors/getRequired.ts","../src/accessors/guards/isValidType.ts","../src/accessors/inferType.ts","../src/accessors/getTypes.ts","../src/accessors/getValidations.ts","../src/accessors/isDeprecated.ts","../src/nodes/RegularNode.ts","../src/nodes/RootNode.ts","../src/guards/nodes.ts","../src/errors.ts","../src/mergers/mergeAllOf.ts","../src/mergers/mergeOneOrAnyOf.ts","../src/walker/walker.ts","../src/tree/tree.ts"],"sourcesContent":["import type { SchemaFragment } from '../types';\nimport type { MirroredRegularNode } from './mirrored';\nimport type { RegularNode } from './RegularNode';\nimport type { RootNode } from './RootNode';\n\nlet SEED = BigInt(0); // cannot use literal, cause TS.\n\nexport abstract class BaseNode {\n  public readonly id: string;\n\n  public parent: RegularNode | RootNode | MirroredRegularNode | null = null;\n  public subpath: string[];\n\n  public get path(): ReadonlyArray<string> {\n    return this.parent === null ? this.subpath : [...this.parent.path, ...this.subpath];\n  }\n\n  public get depth(): number {\n    return this.parent === null ? 0 : this.parent.depth + 1;\n  }\n\n  protected constructor(public readonly fragment: SchemaFragment) {\n    this.id = String(SEED++);\n    this.subpath = [];\n  }\n}\n","import { BaseNode } from '../BaseNode';\nimport type { ReferenceNode } from '../ReferenceNode';\n\nexport class MirroredReferenceNode extends BaseNode implements ReferenceNode {\n  constructor(public readonly mirroredNode: ReferenceNode) {\n    super(mirroredNode.fragment);\n  }\n\n  get error() {\n    return this.mirroredNode.error;\n  }\n\n  get value() {\n    return this.mirroredNode.value;\n  }\n\n  public get external() {\n    return this.mirroredNode.external;\n  }\n}\n","import type { Dictionary } from '@stoplight/types';\n\nexport function isStringOrNumber(value: unknown): value is number | string {\n  return typeof value === 'string' || typeof value === 'number';\n}\n\nexport function isObject(maybeObj: unknown): maybeObj is object {\n  return maybeObj !== void 0 && maybeObj !== null && typeof maybeObj === 'object';\n}\n\nexport function isPrimitive(\n  maybePrimitive: unknown,\n): maybePrimitive is string | number | boolean | undefined | null | symbol | bigint {\n  return typeof maybePrimitive !== 'function' && !isObject(maybePrimitive);\n}\n\nexport function isObjectLiteral(maybeObj: unknown): maybeObj is Dictionary<unknown> {\n  if (isPrimitive(maybeObj) === true) return false;\n  const proto = Object.getPrototypeOf(maybeObj);\n  return proto === null || proto === Object.prototype;\n}\n\nexport function isNonNullable<T = unknown>(maybeNullable: T): maybeNullable is NonNullable<T> {\n  return maybeNullable !== void 0 && maybeNullable !== null;\n}\n","import type { Dictionary } from '@stoplight/types';\n\nexport function pick(target: object, keys: readonly (string | number)[]) {\n  const source: Dictionary<unknown, string | number> = {};\n\n  for (const key of keys) {\n    if (key in target) {\n      source[key] = target[key];\n    }\n  }\n\n  return source;\n}\n","import type { Dictionary } from '@stoplight/types';\n\nimport { isRegularNode } from '../../guards';\nimport type { SchemaFragment } from '../../types';\nimport { isNonNullable } from '../../utils';\nimport { BaseNode } from '../BaseNode';\nimport type { ReferenceNode } from '../ReferenceNode';\nimport type { RegularNode } from '../RegularNode';\nimport type { SchemaAnnotations, SchemaCombinerName, SchemaNodeKind } from '../types';\nimport { MirroredReferenceNode } from './MirroredReferenceNode';\n\nexport class MirroredRegularNode extends BaseNode implements RegularNode {\n  public readonly $id!: string | null;\n  public readonly types!: SchemaNodeKind[] | null;\n  public readonly primaryType!: SchemaNodeKind | null;\n  public readonly combiners!: SchemaCombinerName[] | null;\n\n  public readonly required!: string[] | null;\n  public readonly enum!: unknown[] | null;\n  public readonly format!: string | null;\n  public readonly title!: string | null;\n  public readonly deprecated!: boolean;\n\n  public readonly annotations!: Readonly<Partial<Dictionary<unknown, SchemaAnnotations>>>;\n  public readonly validations!: Readonly<Dictionary<unknown>>;\n  public readonly originalFragment!: SchemaFragment;\n\n  public readonly simple!: boolean;\n  public readonly unknown!: boolean;\n\n  private readonly cache: WeakMap<RegularNode | ReferenceNode, MirroredRegularNode | MirroredReferenceNode>;\n\n  constructor(public readonly mirroredNode: RegularNode, context?: { originalFragment?: SchemaFragment }) {\n    super(mirroredNode.fragment);\n    this.originalFragment = context?.originalFragment ?? mirroredNode.originalFragment;\n\n    this.cache = new WeakMap();\n\n    this._this = new Proxy(this, {\n      get(target, key) {\n        if (key in target) {\n          return target[key];\n        }\n\n        if (key in mirroredNode) {\n          return Reflect.get(mirroredNode, key, mirroredNode);\n        }\n\n        return;\n      },\n\n      has(target, key) {\n        return key in target || key in mirroredNode;\n      },\n    });\n\n    return this._this;\n  }\n\n  private readonly _this: MirroredRegularNode;\n\n  private _children?: (MirroredRegularNode | MirroredReferenceNode)[];\n\n  public get children(): (MirroredRegularNode | MirroredReferenceNode)[] | null | undefined {\n    const referencedChildren = this.mirroredNode.children;\n\n    if (!isNonNullable(referencedChildren)) {\n      return referencedChildren;\n    }\n\n    if (this._children === void 0) {\n      this._children = [];\n    } else {\n      this._children.length = 0;\n    }\n\n    const children: (MirroredRegularNode | MirroredReferenceNode)[] = this._children;\n    for (const child of referencedChildren) {\n      // this is to avoid pointing at nested mirroring\n      const cached = this.cache.get(child);\n\n      if (cached !== void 0) {\n        children.push(cached);\n        continue;\n      }\n\n      const mirroredChild = isRegularNode(child) ? new MirroredRegularNode(child) : new MirroredReferenceNode(child);\n\n      mirroredChild.parent = this._this;\n      mirroredChild.subpath = child.subpath;\n      this.cache.set(child, mirroredChild);\n      children.push(mirroredChild);\n    }\n\n    return children;\n  }\n}\n","export function unwrapStringOrNull(value: unknown): string | null {\n  return typeof value === 'string' ? value : null;\n}\n\nexport function unwrapArrayOrNull(value: unknown): unknown[] | null {\n  return Array.isArray(value) ? value : null;\n}\n","import { isLocalRef } from '@stoplight/json';\n\nimport { unwrapStringOrNull } from '../accessors/unwrap';\nimport type { SchemaFragment } from '../types';\nimport { BaseNode } from './BaseNode';\n\nexport class ReferenceNode extends BaseNode {\n  public readonly value: string | null;\n\n  constructor(fragment: SchemaFragment, public readonly error: string | null) {\n    super(fragment);\n\n    this.value = unwrapStringOrNull(fragment.$ref);\n  }\n\n  public get external() {\n    return this.value !== null && !isLocalRef(this.value);\n  }\n}\n","import type { SchemaFragment } from '../types';\nimport { pick } from '../utils/pick';\n\nconst ANNOTATIONS = ['description', 'default', 'examples'] as const;\n\nexport type SchemaAnnotations = typeof ANNOTATIONS[number];\n\nexport function getAnnotations(fragment: SchemaFragment) {\n  const annotations = pick(fragment, ANNOTATIONS);\n  if ('example' in fragment && !Array.isArray(annotations.examples)) {\n    // example is more OAS-ish, but it's common enough to be worth supporting\n    annotations.examples = [fragment.example];\n  }\n\n  return annotations;\n}\n","import type { MirroredReferenceNode } from './mirrored/MirroredReferenceNode';\nimport type { MirroredRegularNode } from './mirrored/MirroredRegularNode';\nimport type { ReferenceNode } from './ReferenceNode';\nimport type { RegularNode } from './RegularNode';\nimport type { RootNode } from './RootNode';\n\nexport type MirroredSchemaNode = MirroredRegularNode | MirroredReferenceNode;\n\nexport type SchemaNode = RootNode | RegularNode | ReferenceNode | MirroredSchemaNode;\n\nexport enum SchemaNodeKind {\n  Any = 'any',\n  String = 'string',\n  Number = 'number',\n  Integer = 'integer',\n  Boolean = 'boolean',\n  Null = 'null',\n  Array = 'array',\n  Object = 'object',\n}\n\nexport enum SchemaCombinerName {\n  AllOf = 'allOf',\n  AnyOf = 'anyOf',\n  OneOf = 'oneOf',\n}\n\nexport { SchemaAnnotations } from '../accessors/getAnnotations';\n","import { SchemaCombinerName } from '../nodes/types';\nimport type { SchemaFragment } from '../types';\n\nexport function getCombiners(fragment: SchemaFragment): SchemaCombinerName[] | null {\n  let combiners: SchemaCombinerName[] | null = null;\n\n  if (SchemaCombinerName.AnyOf in fragment) {\n    combiners ??= [];\n    combiners.push(SchemaCombinerName.AnyOf);\n  }\n\n  if (SchemaCombinerName.OneOf in fragment) {\n    combiners ??= [];\n    combiners.push(SchemaCombinerName.OneOf);\n  }\n\n  if (SchemaCombinerName.AllOf in fragment) {\n    combiners ??= [];\n    combiners.push(SchemaCombinerName.AllOf);\n  }\n\n  return combiners;\n}\n","import { SchemaNodeKind } from '../nodes/types';\nimport type { SchemaFragment } from '../types';\n\nexport function getPrimaryType(fragment: SchemaFragment, types: SchemaNodeKind[] | null) {\n  if (types !== null) {\n    if (types.includes(SchemaNodeKind.Object)) {\n      return SchemaNodeKind.Object;\n    }\n\n    if (types.includes(SchemaNodeKind.Array)) {\n      return SchemaNodeKind.Array;\n    }\n\n    if (types.length > 0) {\n      return types[0];\n    }\n\n    return null;\n  }\n\n  return null;\n}\n","import { isStringOrNumber } from '../utils/guards';\n\nexport function getRequired(required: unknown): string[] | null {\n  if (!Array.isArray(required)) return null;\n  return required.filter(isStringOrNumber).map(String);\n}\n","import { SchemaNodeKind } from '../../nodes/types';\n\nconst VALID_TYPES = Object.values(SchemaNodeKind);\n\nexport const isValidType = (maybeType: unknown): maybeType is SchemaNodeKind =>\n  typeof maybeType === 'string' && VALID_TYPES.includes(maybeType as SchemaNodeKind);\n","import { SchemaNodeKind } from '../nodes/types';\nimport type { SchemaFragment } from '../types';\n\nexport function inferType(fragment: SchemaFragment): SchemaNodeKind | null {\n  if ('properties' in fragment || 'additionalProperties' in fragment || 'patternProperties' in fragment) {\n    return SchemaNodeKind.Object;\n  }\n\n  if ('items' in fragment || 'additionalItems' in fragment) {\n    return SchemaNodeKind.Array;\n  }\n\n  return null;\n}\n","import type { SchemaNodeKind } from '../nodes/types';\nimport type { SchemaFragment } from '../types';\nimport { isValidType } from './guards/isValidType';\nimport { inferType } from './inferType';\n\nexport function getTypes(fragment: SchemaFragment): SchemaNodeKind[] | null {\n  if ('type' in fragment) {\n    if (Array.isArray(fragment.type)) {\n      return fragment.type.filter(isValidType);\n    } else if (isValidType(fragment.type)) {\n      return [fragment.type];\n    }\n  }\n\n  const inferredType = inferType(fragment);\n  if (inferredType !== null) {\n    return [inferredType];\n  }\n\n  return null;\n}\n","import type { Dictionary } from '@stoplight/types';\n\nimport type { SchemaNodeKind } from '../nodes/types';\nimport type { SchemaFragment } from '../types';\nimport { pick } from '../utils/pick';\n\nexport const COMMON_VALIDATION_TYPES: string[] = ['readOnly', 'writeOnly', 'style'];\n\nconst VALIDATION_TYPES: Partial<Dictionary<(keyof SchemaFragment)[], SchemaNodeKind>> = {\n  string: ['minLength', 'maxLength', 'pattern'],\n  number: ['multipleOf', 'minimum', 'exclusiveMinimum', 'maximum', 'exclusiveMaximum'],\n  get integer() {\n    return this.number;\n  },\n  object: ['additionalProperties', 'minProperties', 'maxProperties'],\n  array: ['additionalItems', 'minItems', 'maxItems', 'uniqueItems'],\n};\n\nfunction getTypeValidations(types: SchemaNodeKind[]): (keyof SchemaFragment)[] | null {\n  let extraValidations: (keyof SchemaFragment)[] | null = null;\n\n  for (const type of types) {\n    const value = VALIDATION_TYPES[type];\n    if (value !== void 0) {\n      extraValidations ??= [];\n      extraValidations.push(...value);\n    }\n  }\n\n  return extraValidations;\n}\n\nexport function getValidations(fragment: SchemaFragment, types: SchemaNodeKind[] | null): Dictionary<unknown> {\n  const extraValidations = types === null ? null : getTypeValidations(types);\n\n  return {\n    ...pick(fragment, COMMON_VALIDATION_TYPES),\n    ...(extraValidations !== null ? pick(fragment, extraValidations) : null),\n  };\n}\n","import type { SchemaFragment } from '../types';\n\nexport function isDeprecated(fragment: SchemaFragment): boolean {\n  if ('x-deprecated' in fragment) {\n    return fragment['x-deprecated'] === true;\n  }\n\n  if ('deprecated' in fragment) {\n    return fragment.deprecated === true;\n  }\n\n  return false;\n}\n","import type { Dictionary } from '@stoplight/types';\n\nimport { getAnnotations } from '../accessors/getAnnotations';\nimport { getCombiners } from '../accessors/getCombiners';\nimport { getPrimaryType } from '../accessors/getPrimaryType';\nimport { getRequired } from '../accessors/getRequired';\nimport { getTypes } from '../accessors/getTypes';\nimport { getValidations } from '../accessors/getValidations';\nimport { isDeprecated } from '../accessors/isDeprecated';\nimport { unwrapArrayOrNull, unwrapStringOrNull } from '../accessors/unwrap';\nimport type { SchemaFragment } from '../types';\nimport { BaseNode } from './BaseNode';\nimport type { ReferenceNode } from './ReferenceNode';\nimport { MirroredSchemaNode, SchemaAnnotations, SchemaCombinerName, SchemaNodeKind } from './types';\n\nexport class RegularNode extends BaseNode {\n  public readonly $id: string | null;\n  public readonly types: SchemaNodeKind[] | null;\n  public readonly primaryType: SchemaNodeKind | null; // object (first choice) or array (second option), primitive last\n  public readonly combiners: SchemaCombinerName[] | null;\n\n  public readonly required: string[] | null;\n  public readonly enum: unknown[] | null; // https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.5.1\n  public readonly format: string | null; // https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-7\n  public readonly title: string | null;\n  public readonly deprecated: boolean;\n\n  public children: (RegularNode | ReferenceNode | MirroredSchemaNode)[] | null | undefined;\n\n  public readonly annotations: Readonly<Partial<Dictionary<unknown, SchemaAnnotations>>>;\n  public readonly validations: Readonly<Dictionary<unknown>>;\n  public readonly originalFragment: SchemaFragment;\n\n  constructor(public readonly fragment: SchemaFragment, context?: { originalFragment?: SchemaFragment }) {\n    super(fragment);\n\n    this.$id = unwrapStringOrNull('id' in fragment ? fragment.id : fragment.$id);\n    this.types = getTypes(fragment);\n    this.primaryType = getPrimaryType(fragment, this.types);\n    this.combiners = getCombiners(fragment);\n\n    this.deprecated = isDeprecated(fragment);\n    this.enum = 'const' in fragment ? [fragment.const] : unwrapArrayOrNull(fragment.enum);\n    this.required = getRequired(fragment.required);\n    this.format = unwrapStringOrNull(fragment.format);\n    this.title = unwrapStringOrNull(fragment.title);\n\n    this.annotations = getAnnotations(fragment);\n    this.validations = getValidations(fragment, this.types);\n    this.originalFragment = context?.originalFragment ?? fragment;\n\n    this.children = void 0;\n  }\n\n  public get simple() {\n    return (\n      this.primaryType !== SchemaNodeKind.Array && this.primaryType !== SchemaNodeKind.Object && this.combiners === null\n    );\n  }\n\n  public get unknown() {\n    return (\n      this.types === null &&\n      this.combiners === null &&\n      this.format === null &&\n      this.enum === null &&\n      Object.keys(this.annotations).length + Object.keys(this.validations).length === 0\n    );\n  }\n}\n","import type { SchemaFragment } from '../types';\nimport { BaseNode } from './BaseNode';\nimport type { SchemaNode } from './types';\n\nexport class RootNode extends BaseNode {\n  public readonly parent = null;\n  public readonly children: SchemaNode[];\n\n  constructor(public readonly fragment: SchemaFragment) {\n    super(fragment);\n    this.children = [];\n  }\n}\n","import {\n  MirroredReferenceNode,\n  MirroredRegularNode,\n  MirroredSchemaNode,\n  ReferenceNode,\n  RegularNode,\n  RootNode,\n  SchemaNode,\n} from '../nodes';\n\nexport function isSchemaNode(node: unknown): node is SchemaNode {\n  const name = Object.getPrototypeOf(node).constructor.name;\n  return (\n    name === RootNode.name ||\n    name === RegularNode.name ||\n    name === MirroredRegularNode.name ||\n    name === ReferenceNode.name ||\n    name === MirroredReferenceNode.name\n  );\n}\n\nexport function isRootNode(node: SchemaNode): node is RootNode {\n  return Object.getPrototypeOf(node).constructor.name === 'RootNode';\n}\n\nexport function isRegularNode(node: SchemaNode): node is RegularNode {\n  return 'types' in node && 'primaryType' in node && 'combiners' in node;\n}\n\nexport function isMirroredNode(node: SchemaNode): node is MirroredSchemaNode {\n  return 'mirroredNode' in node;\n}\n\nexport function isReferenceNode(node: SchemaNode): node is ReferenceNode {\n  return 'external' in node && 'value' in node;\n}\n","export class ResolvingError extends ReferenceError {\n  public readonly name = 'ResolvingError';\n}\n\nexport class MergingError extends Error {\n  public readonly name = 'MergingError';\n}\n","import { pathToPointer, stringify } from '@stoplight/json';\n\nimport { ResolvingError } from '../errors';\nimport type { SchemaFragment } from '../types';\nimport type { WalkerRefResolver, WalkingOptions } from '../walker/types';\n\nconst resolveAllOf = require('@stoplight/json-schema-merge-allof');\n\nconst store = new WeakMap<WalkerRefResolver, WeakMap<SchemaFragment, string[]>>();\n\nfunction _mergeAllOf(fragment: SchemaFragment, path: string[], resolveRef: WalkerRefResolver | null): SchemaFragment {\n  return resolveAllOf(fragment, {\n    deep: false,\n    resolvers: resolveAllOf.stoplightResolvers,\n    ...(resolveRef !== null\n      ? {\n          $refResolver($ref: unknown) {\n            if (typeof $ref !== 'string') {\n              return {};\n            }\n\n            if (pathToPointer(path).startsWith($ref)) {\n              throw new ResolvingError('Circular reference detected');\n            }\n\n            const allRefs = store.get(resolveRef)!;\n            let schemaRefs = allRefs.get(fragment);\n\n            if (schemaRefs === void 0) {\n              schemaRefs = [$ref];\n              allRefs.set(fragment, schemaRefs);\n            } else if (schemaRefs.includes($ref)) {\n              const safelyResolved = JSON.parse(stringify(resolveRef(null, $ref)));\n              return 'allOf' in safelyResolved ? _mergeAllOf(safelyResolved, path, resolveRef) : safelyResolved;\n            } else {\n              schemaRefs.push($ref);\n            }\n\n            const resolved = resolveRef(null, $ref);\n\n            if (Array.isArray(resolved.allOf)) {\n              for (const member of resolved.allOf) {\n                const index = schemaRefs.indexOf(member.$ref);\n                if (typeof member.$ref === 'string' && index !== -1 && index !== schemaRefs.lastIndexOf(member.$ref)) {\n                  throw new ResolvingError('Circular reference detected');\n                }\n              }\n            }\n\n            return resolved;\n          },\n        }\n      : null),\n  });\n}\n\nexport function mergeAllOf(fragment: SchemaFragment, path: string[], walkingOptions: WalkingOptions) {\n  if (walkingOptions.resolveRef !== null && !store.has(walkingOptions.resolveRef)) {\n    store.set(walkingOptions.resolveRef, new WeakMap());\n  }\n\n  const merged = _mergeAllOf(fragment, path, walkingOptions.resolveRef);\n  if ('allOf' in merged) {\n    return _mergeAllOf(merged, path, walkingOptions.resolveRef);\n  }\n\n  return merged;\n}\n","import { SchemaCombinerName } from '../nodes/types';\nimport type { SchemaFragment } from '../types';\nimport type { WalkingOptions } from '../walker/types';\nimport { mergeAllOf } from './mergeAllOf';\n\nexport function mergeOneOrAnyOf(\n  fragment: SchemaFragment,\n  path: string[],\n  walkingOptions: WalkingOptions,\n): SchemaFragment[] {\n  const combiner = SchemaCombinerName.OneOf in fragment ? SchemaCombinerName.OneOf : SchemaCombinerName.AnyOf;\n  const items = fragment[combiner];\n\n  if (!Array.isArray(items)) return []; // just in case\n\n  const merged: SchemaFragment[] = [];\n\n  if (Array.isArray(fragment.allOf) && Array.isArray(items)) {\n    for (const item of items) {\n      merged.push({\n        allOf: [...fragment.allOf, item],\n      });\n    }\n\n    return merged;\n  } else {\n    for (const item of items) {\n      const prunedSchema = { ...fragment };\n      delete prunedSchema[combiner];\n\n      if (Object.keys(prunedSchema).length === 0) {\n        merged.push(item);\n      } else {\n        const resolvedItem =\n          typeof item.$ref === 'string' && walkingOptions.resolveRef !== null\n            ? walkingOptions.resolveRef(null, item.$ref)\n            : item;\n        const mergedSchema = {\n          allOf: [prunedSchema, resolvedItem],\n        };\n\n        try {\n          merged.push(mergeAllOf(mergedSchema, path, walkingOptions));\n        } catch {\n          merged.push(mergedSchema);\n        }\n      }\n    }\n  }\n\n  return merged;\n}\n","import { EventEmitter } from '@stoplight/lifecycle';\nimport type { Dictionary } from '@stoplight/types';\nimport createMagicError from 'magic-error';\n\nimport { MergingError } from '../errors';\nimport { isMirroredNode, isReferenceNode, isRegularNode, isRootNode } from '../guards';\nimport { mergeAllOf } from '../mergers/mergeAllOf';\nimport { mergeOneOrAnyOf } from '../mergers/mergeOneOrAnyOf';\nimport { MirroredReferenceNode, MirroredRegularNode, MirroredSchemaNode, ReferenceNode, RegularNode } from '../nodes';\nimport type { RootNode } from '../nodes/RootNode';\nimport { SchemaCombinerName, SchemaNode, SchemaNodeKind } from '../nodes/types';\nimport type { SchemaFragment } from '../types';\nimport { isNonNullable, isObjectLiteral } from '../utils/guards';\nimport type { WalkerEmitter, WalkerHookAction, WalkerHookHandler, WalkerSnapshot, WalkingOptions } from './types';\n\ntype InternalWalkerState = {\n  depth: number;\n  pathLength: number;\n  schemaNode: RegularNode | RootNode;\n};\n\ntype ProcessedFragment = SchemaFragment | SchemaFragment[];\n\nexport class Walker extends EventEmitter<WalkerEmitter> {\n  public readonly path: string[];\n  public depth: number;\n\n  protected fragment: SchemaFragment;\n  protected schemaNode: RegularNode | RootNode;\n\n  private processedFragments: WeakMap<ProcessedFragment, SchemaNode>;\n  private readonly hooks: Partial<Dictionary<WalkerHookHandler, WalkerHookAction>>;\n\n  constructor(protected readonly root: RootNode, protected readonly walkingOptions: WalkingOptions) {\n    super();\n\n    this.path = [];\n    this.depth = -1;\n    this.fragment = root.fragment;\n    this.schemaNode = root;\n    this.processedFragments = new WeakMap<SchemaFragment, SchemaNode>();\n\n    this.hooks = {};\n  }\n\n  public destroy() {\n    this.path.length = 0;\n    this.depth = -1;\n    this.fragment = this.root.fragment;\n    this.schemaNode = this.root;\n    this.processedFragments = new WeakMap<SchemaFragment, RegularNode | ReferenceNode>();\n  }\n\n  public loadSnapshot(snapshot: WalkerSnapshot) {\n    this.path.splice(0, this.path.length, ...snapshot.path);\n    this.depth = snapshot.depth;\n    this.fragment = snapshot.fragment;\n    this.schemaNode = snapshot.schemaNode;\n  }\n\n  public saveSnapshot(): WalkerSnapshot {\n    return {\n      depth: this.depth,\n      fragment: this.fragment,\n      schemaNode: this.schemaNode,\n      path: this.path.slice(),\n    };\n  }\n\n  public hookInto(action: WalkerHookAction, handler: WalkerHookHandler) {\n    this.hooks[action] = handler;\n  }\n\n  public restoreWalkerAtNode(node: RegularNode) {\n    this.processedFragments.delete(node.fragment);\n    this.path.splice(0, this.path.length, ...node.path);\n    this.depth = node.depth;\n    this.fragment = node.fragment;\n    this.schemaNode = node;\n  }\n\n  public walk(): void {\n    const { depth: initialDepth, fragment } = this;\n    let { schemaNode: initialSchemaNode } = this;\n\n    if (initialDepth === -1 && Object.keys(fragment).length === 0) {\n      // empty schema, nothing to do\n      return;\n    }\n\n    while (isMirroredNode(initialSchemaNode)) {\n      if (!isRegularNode(initialSchemaNode.mirroredNode)) {\n        return;\n      }\n\n      if (initialSchemaNode.mirroredNode.children === void 0) {\n        this.restoreWalkerAtNode(initialSchemaNode.mirroredNode);\n        initialSchemaNode = this.schemaNode;\n        this.depth = initialDepth;\n      } else {\n        return;\n      }\n    }\n\n    const state = this.dumpInternalWalkerState();\n\n    super.emit('enterFragment', fragment);\n    const [schemaNode, initialFragment] = this.processFragment();\n    super.emit('enterNode', schemaNode);\n\n    const actualNode = isMirroredNode(schemaNode) ? schemaNode.mirroredNode : schemaNode;\n    this.processedFragments.set(schemaNode.fragment, actualNode);\n    this.processedFragments.set(initialFragment, actualNode);\n\n    this.fragment = schemaNode.fragment;\n    this.depth = initialDepth + 1;\n\n    const isIncluded = this.hooks.filter?.(schemaNode);\n\n    if (isIncluded === false) {\n      super.emit('skipNode', schemaNode);\n      return;\n    }\n\n    if (!isRootNode(schemaNode)) {\n      schemaNode.parent = initialSchemaNode;\n      schemaNode.subpath = this.path.slice(initialSchemaNode.path.length);\n    }\n\n    if ('children' in initialSchemaNode && !isRootNode(schemaNode)) {\n      if (initialSchemaNode.children === void 0) {\n        (initialSchemaNode as RegularNode).children = [schemaNode];\n      } else {\n        initialSchemaNode.children!.push(schemaNode);\n      }\n    }\n\n    super.emit('includeNode', schemaNode);\n\n    if (isRegularNode(schemaNode)) {\n      this.schemaNode = schemaNode;\n\n      if (this.hooks.stepIn?.(schemaNode) !== false) {\n        super.emit('stepInNode', schemaNode);\n        this.walkNodeChildren();\n        super.emit('stepOutNode', schemaNode);\n      } else {\n        super.emit('stepOverNode', schemaNode);\n      }\n    }\n\n    super.emit('exitNode', schemaNode);\n    this.restoreInternalWalkerState(state);\n    super.emit('exitFragment', fragment);\n  }\n\n  protected dumpInternalWalkerState(): InternalWalkerState {\n    return {\n      depth: this.depth,\n      pathLength: this.path.length,\n      schemaNode: this.schemaNode,\n    };\n  }\n\n  protected restoreInternalWalkerState({ depth, pathLength, schemaNode }: InternalWalkerState) {\n    this.depth = depth;\n    this.path.length = pathLength;\n    this.schemaNode = schemaNode;\n  }\n\n  protected walkNodeChildren(): void {\n    const { fragment, schemaNode } = this;\n\n    if (!isRegularNode(schemaNode)) return;\n\n    const state = this.dumpInternalWalkerState();\n\n    if (schemaNode.combiners !== null) {\n      for (const combiner of schemaNode.combiners) {\n        const items = fragment[combiner];\n        if (!Array.isArray(items)) continue;\n\n        let i = -1;\n        for (const item of items) {\n          i++;\n          if (!isObjectLiteral(item)) continue;\n          this.fragment = item;\n          this.restoreInternalWalkerState(state);\n          this.path.push(combiner, String(i));\n          this.walk();\n        }\n      }\n    }\n\n    switch (schemaNode.primaryType) {\n      case SchemaNodeKind.Array:\n        if (Array.isArray(fragment.items)) {\n          let i = -1;\n          for (const item of fragment.items) {\n            i++;\n            if (!isObjectLiteral(item)) continue;\n            this.fragment = item;\n            this.restoreInternalWalkerState(state);\n            this.path.push('items', String(i));\n            this.walk();\n          }\n        } else if (isObjectLiteral(fragment.items)) {\n          this.fragment = fragment.items;\n          this.restoreInternalWalkerState(state);\n          this.path.push('items');\n          this.walk();\n        }\n\n        break;\n      case SchemaNodeKind.Object:\n        if (isObjectLiteral(fragment.properties)) {\n          for (const key of Object.keys(fragment.properties)) {\n            const value = fragment.properties[key];\n            if (!isObjectLiteral(value)) continue;\n            this.fragment = value;\n            this.restoreInternalWalkerState(state);\n            this.path.push('properties', key);\n            this.walk();\n          }\n        }\n\n        if (isObjectLiteral(fragment.patternProperties)) {\n          for (const key of Object.keys(fragment.patternProperties)) {\n            const value = fragment.patternProperties[key];\n            if (!isObjectLiteral(value)) continue;\n            this.fragment = value;\n            this.restoreInternalWalkerState(state);\n            this.path.push('patternProperties', key);\n            this.walk();\n          }\n        }\n\n        break;\n    }\n\n    this.schemaNode = schemaNode;\n  }\n\n  protected retrieveFromFragment(\n    fragment: ProcessedFragment,\n    originalFragment: SchemaFragment,\n  ): [MirroredSchemaNode, ProcessedFragment] | void {\n    const processedSchemaNode = this.processedFragments.get(fragment);\n    if (processedSchemaNode !== void 0) {\n      if (isRegularNode(processedSchemaNode)) {\n        return [new MirroredRegularNode(processedSchemaNode, { originalFragment }), fragment];\n      }\n\n      if (isReferenceNode(processedSchemaNode)) {\n        return [new MirroredReferenceNode(processedSchemaNode), fragment];\n      }\n\n      // whoops, we don't know what to do with it\n      throw new TypeError('Cannot mirror the node');\n    }\n  }\n\n  protected processFragment(): [SchemaNode, ProcessedFragment] {\n    const { walkingOptions, path, fragment: originalFragment } = this;\n    let { fragment } = this;\n\n    let retrieved = isNonNullable(fragment) ? this.retrieveFromFragment(fragment, originalFragment) : null;\n\n    if (retrieved) {\n      return retrieved;\n    }\n\n    if ('$ref' in fragment) {\n      if (typeof fragment.$ref !== 'string') {\n        return [new ReferenceNode(fragment, '$ref is not a string'), fragment];\n      } else if (walkingOptions.resolveRef !== null) {\n        try {\n          fragment = walkingOptions.resolveRef(path, fragment.$ref);\n        } catch (ex) {\n          super.emit('error', createMagicError(ex));\n          return [new ReferenceNode(fragment, ex?.message ?? 'Unknown resolving error'), fragment];\n        }\n      } else {\n        return [new ReferenceNode(fragment, null), fragment];\n      }\n    }\n\n    let initialFragment: ProcessedFragment = fragment;\n    if (walkingOptions.mergeAllOf && SchemaCombinerName.AllOf in fragment) {\n      try {\n        if (Array.isArray(fragment.allOf)) {\n          initialFragment = fragment.allOf;\n        }\n\n        fragment = mergeAllOf(fragment, path, walkingOptions);\n      } catch (ex) {\n        initialFragment = fragment;\n        super.emit('error', createMagicError(new MergingError(ex?.message ?? 'Unknown merging error')));\n        // no the end of the world - we will render raw unprocessed fragment\n      }\n    }\n\n    if (SchemaCombinerName.OneOf in fragment || SchemaCombinerName.AnyOf in fragment) {\n      try {\n        const merged = mergeOneOrAnyOf(fragment, path, walkingOptions);\n        if (merged.length === 1) {\n          return [new RegularNode(merged[0], { originalFragment }), initialFragment];\n        } else {\n          const combiner = SchemaCombinerName.OneOf in fragment ? SchemaCombinerName.OneOf : SchemaCombinerName.AnyOf;\n          return [new RegularNode({ [combiner]: merged }, { originalFragment }), initialFragment];\n        }\n      } catch (ex) {\n        super.emit('error', createMagicError(new MergingError(ex?.message ?? 'Unknown merging error')));\n        // no the end of the world - we will render raw unprocessed fragment\n      }\n    }\n\n    retrieved = isNonNullable(fragment) ? this.retrieveFromFragment(initialFragment, originalFragment) : null;\n\n    if (retrieved) {\n      return retrieved;\n    }\n\n    return [new RegularNode(fragment, { originalFragment }), initialFragment];\n  }\n}\n","import { extractPointerFromRef, extractSourceFromRef, resolveInlineRef } from '@stoplight/json';\n\nimport { ResolvingError } from '../errors';\nimport { RootNode } from '../nodes/RootNode';\nimport type { SchemaFragment } from '../types';\nimport { isObjectLiteral } from '../utils';\nimport { Walker } from '../walker';\nimport type { WalkerRefResolver } from '../walker/types';\nimport type { SchemaTreeOptions } from './types';\n\nexport class SchemaTree {\n  public walker: Walker;\n  public root: RootNode;\n\n  constructor(public schema: SchemaFragment, protected readonly opts?: Partial<SchemaTreeOptions>) {\n    this.root = new RootNode(schema);\n    this.walker = new Walker(this.root, {\n      mergeAllOf: this.opts?.mergeAllOf !== false,\n      resolveRef: opts?.refResolver === null ? null : this.resolveRef,\n    });\n  }\n\n  public destroy() {\n    this.root.children.length = 0;\n    this.walker.destroy();\n  }\n\n  public populate() {\n    this.invokeWalker(this.walker);\n  }\n\n  public invokeWalker(walker: Walker) {\n    walker.walk();\n  }\n\n  protected resolveRef: WalkerRefResolver = (path, $ref) => {\n    const seenRefs: string[] = [];\n    let cur$ref: unknown = $ref;\n    let resolvedValue!: SchemaFragment;\n\n    while (typeof cur$ref === 'string') {\n      if (seenRefs.includes(cur$ref)) {\n        break;\n      }\n\n      seenRefs.push(cur$ref);\n      resolvedValue = this._resolveRef(path, cur$ref);\n      cur$ref = resolvedValue.$ref;\n    }\n\n    return resolvedValue;\n  };\n\n  private _resolveRef: WalkerRefResolver = (path, $ref) => {\n    const source = extractSourceFromRef($ref);\n    const pointer = extractPointerFromRef($ref);\n    const refResolver = this.opts?.refResolver;\n\n    if (typeof refResolver === 'function') {\n      return refResolver({ source, pointer }, path, this.schema);\n    } else if (source !== null) {\n      throw new ResolvingError('Cannot dereference external references');\n    } else if (pointer === null) {\n      throw new ResolvingError('The pointer is empty');\n    } else if (isObjectLiteral(this.schema)) {\n      const value = resolveInlineRef(this.schema, pointer);\n      if (!isObjectLiteral(value)) {\n        throw new ResolvingError('Invalid value');\n      }\n\n      return value;\n    } else {\n      throw new ResolvingError('Unexpected input');\n    }\n  };\n}\n"],"names":["isLocalRef","SchemaNodeKind","SchemaCombinerName","pathToPointer","stringify","EventEmitter","extractSourceFromRef","extractPointerFromRef","resolveInlineRef"],"mappings":";;;;;;;;;;AAKA,IAAI,IAAI,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC;MAEC,QAAQ;IAc5B,YAAsC,QAAwB;QAAxB,aAAQ,GAAR,QAAQ,CAAgB;QAXvD,WAAM,GAAwD,IAAI,CAAC;QAYxE,IAAI,CAAC,EAAE,GAAG,MAAM,CAAC,IAAI,EAAE,CAAC,CAAC;QACzB,IAAI,CAAC,OAAO,GAAG,EAAE,CAAC;KACnB;IAXD,IAAW,IAAI;QACb,OAAO,IAAI,CAAC,MAAM,KAAK,IAAI,GAAG,IAAI,CAAC,OAAO,GAAG,CAAC,GAAG,IAAI,CAAC,MAAM,CAAC,IAAI,EAAE,GAAG,IAAI,CAAC,OAAO,CAAC,CAAC;KACrF;IAED,IAAW,KAAK;QACd,OAAO,IAAI,CAAC,MAAM,KAAK,IAAI,GAAG,CAAC,GAAG,IAAI,CAAC,MAAM,CAAC,KAAK,GAAG,CAAC,CAAC;KACzD;;;MChBU,qBAAsB,SAAQ,QAAQ;IACjD,YAA4B,YAA2B;QACrD,KAAK,CAAC,YAAY,CAAC,QAAQ,CAAC,CAAC;QADH,iBAAY,GAAZ,YAAY,CAAe;KAEtD;IAED,IAAI,KAAK;QACP,OAAO,IAAI,CAAC,YAAY,CAAC,KAAK,CAAC;KAChC;IAED,IAAI,KAAK;QACP,OAAO,IAAI,CAAC,YAAY,CAAC,KAAK,CAAC;KAChC;IAED,IAAW,QAAQ;QACjB,OAAO,IAAI,CAAC,YAAY,CAAC,QAAQ,CAAC;KACnC;CACF;;SCjBe,gBAAgB,CAAC,KAAc;IAC7C,OAAO,OAAO,KAAK,KAAK,QAAQ,IAAI,OAAO,KAAK,KAAK,QAAQ,CAAC;AAChE,CAAC;AAED,SAAgB,QAAQ,CAAC,QAAiB;IACxC,OAAO,QAAQ,KAAK,KAAK,CAAC,IAAI,QAAQ,KAAK,IAAI,IAAI,OAAO,QAAQ,KAAK,QAAQ,CAAC;AAClF,CAAC;AAED,SAAgB,WAAW,CACzB,cAAuB;IAEvB,OAAO,OAAO,cAAc,KAAK,UAAU,IAAI,CAAC,QAAQ,CAAC,cAAc,CAAC,CAAC;AAC3E,CAAC;AAED,SAAgB,eAAe,CAAC,QAAiB;IAC/C,IAAI,WAAW,CAAC,QAAQ,CAAC,KAAK,IAAI;QAAE,OAAO,KAAK,CAAC;IACjD,MAAM,KAAK,GAAG,MAAM,CAAC,cAAc,CAAC,QAAQ,CAAC,CAAC;IAC9C,OAAO,KAAK,KAAK,IAAI,IAAI,KAAK,KAAK,MAAM,CAAC,SAAS,CAAC;AACtD,CAAC;AAED,SAAgB,aAAa,CAAc,aAAgB;IACzD,OAAO,aAAa,KAAK,KAAK,CAAC,IAAI,aAAa,KAAK,IAAI,CAAC;AAC5D,CAAC;;SCtBe,IAAI,CAAC,MAAc,EAAE,IAAkC;IACrE,MAAM,MAAM,GAAyC,EAAE,CAAC;IAExD,KAAK,MAAM,GAAG,IAAI,IAAI,EAAE;QACtB,IAAI,GAAG,IAAI,MAAM,EAAE;YACjB,MAAM,CAAC,GAAG,CAAC,GAAG,MAAM,CAAC,GAAG,CAAC,CAAC;SAC3B;KACF;IAED,OAAO,MAAM,CAAC;AAChB,CAAC;;MCDY,mBAAoB,SAAQ,QAAQ;IAqB/C,YAA4B,YAAyB,EAAE,OAA+C;;QACpG,KAAK,CAAC,YAAY,CAAC,QAAQ,CAAC,CAAC;QADH,iBAAY,GAAZ,YAAY,CAAa;QAEnD,IAAI,CAAC,gBAAgB,SAAG,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,gBAAgB,mCAAI,YAAY,CAAC,gBAAgB,CAAC;QAEnF,IAAI,CAAC,KAAK,GAAG,IAAI,OAAO,EAAE,CAAC;QAE3B,IAAI,CAAC,KAAK,GAAG,IAAI,KAAK,CAAC,IAAI,EAAE;YAC3B,GAAG,CAAC,MAAM,EAAE,GAAG;gBACb,IAAI,GAAG,IAAI,MAAM,EAAE;oBACjB,OAAO,MAAM,CAAC,GAAG,CAAC,CAAC;iBACpB;gBAED,IAAI,GAAG,IAAI,YAAY,EAAE;oBACvB,OAAO,OAAO,CAAC,GAAG,CAAC,YAAY,EAAE,GAAG,EAAE,YAAY,CAAC,CAAC;iBACrD;gBAED,OAAO;aACR;YAED,GAAG,CAAC,MAAM,EAAE,GAAG;gBACb,OAAO,GAAG,IAAI,MAAM,IAAI,GAAG,IAAI,YAAY,CAAC;aAC7C;SACF,CAAC,CAAC;QAEH,OAAO,IAAI,CAAC,KAAK,CAAC;KACnB;IAMD,IAAW,QAAQ;QACjB,MAAM,kBAAkB,GAAG,IAAI,CAAC,YAAY,CAAC,QAAQ,CAAC;QAEtD,IAAI,CAAC,aAAa,CAAC,kBAAkB,CAAC,EAAE;YACtC,OAAO,kBAAkB,CAAC;SAC3B;QAED,IAAI,IAAI,CAAC,SAAS,KAAK,KAAK,CAAC,EAAE;YAC7B,IAAI,CAAC,SAAS,GAAG,EAAE,CAAC;SACrB;aAAM;YACL,IAAI,CAAC,SAAS,CAAC,MAAM,GAAG,CAAC,CAAC;SAC3B;QAED,MAAM,QAAQ,GAAoD,IAAI,CAAC,SAAS,CAAC;QACjF,KAAK,MAAM,KAAK,IAAI,kBAAkB,EAAE;YAEtC,MAAM,MAAM,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;YAErC,IAAI,MAAM,KAAK,KAAK,CAAC,EAAE;gBACrB,QAAQ,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;gBACtB,SAAS;aACV;YAED,MAAM,aAAa,GAAG,aAAa,CAAC,KAAK,CAAC,GAAG,IAAI,mBAAmB,CAAC,KAAK,CAAC,GAAG,IAAI,qBAAqB,CAAC,KAAK,CAAC,CAAC;YAE/G,aAAa,CAAC,MAAM,GAAG,IAAI,CAAC,KAAK,CAAC;YAClC,aAAa,CAAC,OAAO,GAAG,KAAK,CAAC,OAAO,CAAC;YACtC,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,KAAK,EAAE,aAAa,CAAC,CAAC;YACrC,QAAQ,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC;SAC9B;QAED,OAAO,QAAQ,CAAC;KACjB;CACF;;SChGe,kBAAkB,CAAC,KAAc;IAC/C,OAAO,OAAO,KAAK,KAAK,QAAQ,GAAG,KAAK,GAAG,IAAI,CAAC;AAClD,CAAC;AAED,SAAgB,iBAAiB,CAAC,KAAc;IAC9C,OAAO,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,GAAG,KAAK,GAAG,IAAI,CAAC;AAC7C,CAAC;;MCAY,aAAc,SAAQ,QAAQ;IAGzC,YAAY,QAAwB,EAAkB,KAAoB;QACxE,KAAK,CAAC,QAAQ,CAAC,CAAC;QADoC,UAAK,GAAL,KAAK,CAAe;QAGxE,IAAI,CAAC,KAAK,GAAG,kBAAkB,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;KAChD;IAED,IAAW,QAAQ;QACjB,OAAO,IAAI,CAAC,KAAK,KAAK,IAAI,IAAI,CAACA,eAAU,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;KACvD;CACF;;ACfD,MAAM,WAAW,GAAG,CAAC,aAAa,EAAE,SAAS,EAAE,UAAU,CAAU,CAAC;AAIpE,SAAgB,cAAc,CAAC,QAAwB;IACrD,MAAM,WAAW,GAAG,IAAI,CAAC,QAAQ,EAAE,WAAW,CAAC,CAAC;IAChD,IAAI,SAAS,IAAI,QAAQ,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,WAAW,CAAC,QAAQ,CAAC,EAAE;QAEjE,WAAW,CAAC,QAAQ,GAAG,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC;KAC3C;IAED,OAAO,WAAW,CAAC;AACrB,CAAC;;ACLD,WAAY,cAAc;IACxB,6BAAW,CAAA;IACX,mCAAiB,CAAA;IACjB,mCAAiB,CAAA;IACjB,qCAAmB,CAAA;IACnB,qCAAmB,CAAA;IACnB,+BAAa,CAAA;IACb,iCAAe,CAAA;IACf,mCAAiB,CAAA;AACnB,CAAC,EATWC,sBAAc,KAAdA,sBAAc,QASzB;AAED,AAAA,WAAY,kBAAkB;IAC5B,qCAAe,CAAA;IACf,qCAAe,CAAA;IACf,qCAAe,CAAA;AACjB,CAAC,EAJWC,0BAAkB,KAAlBA,0BAAkB,QAI7B;;SCtBe,YAAY,CAAC,QAAwB;IACnD,IAAI,SAAS,GAAgC,IAAI,CAAC;IAElD,IAAIA,0BAAkB,CAAC,KAAK,IAAI,QAAQ,EAAE;QACxC,SAAS,aAAT,SAAS,cAAT,SAAS,IAAT,SAAS,GAAK,EAAE,EAAC;QACjB,SAAS,CAAC,IAAI,CAACA,0BAAkB,CAAC,KAAK,CAAC,CAAC;KAC1C;IAED,IAAIA,0BAAkB,CAAC,KAAK,IAAI,QAAQ,EAAE;QACxC,SAAS,aAAT,SAAS,cAAT,SAAS,IAAT,SAAS,GAAK,EAAE,EAAC;QACjB,SAAS,CAAC,IAAI,CAACA,0BAAkB,CAAC,KAAK,CAAC,CAAC;KAC1C;IAED,IAAIA,0BAAkB,CAAC,KAAK,IAAI,QAAQ,EAAE;QACxC,SAAS,aAAT,SAAS,cAAT,SAAS,IAAT,SAAS,GAAK,EAAE,EAAC;QACjB,SAAS,CAAC,IAAI,CAACA,0BAAkB,CAAC,KAAK,CAAC,CAAC;KAC1C;IAED,OAAO,SAAS,CAAC;AACnB,CAAC;;SCnBe,cAAc,CAAC,QAAwB,EAAE,KAA8B;IACrF,IAAI,KAAK,KAAK,IAAI,EAAE;QAClB,IAAI,KAAK,CAAC,QAAQ,CAACD,sBAAc,CAAC,MAAM,CAAC,EAAE;YACzC,OAAOA,sBAAc,CAAC,MAAM,CAAC;SAC9B;QAED,IAAI,KAAK,CAAC,QAAQ,CAACA,sBAAc,CAAC,KAAK,CAAC,EAAE;YACxC,OAAOA,sBAAc,CAAC,KAAK,CAAC;SAC7B;QAED,IAAI,KAAK,CAAC,MAAM,GAAG,CAAC,EAAE;YACpB,OAAO,KAAK,CAAC,CAAC,CAAC,CAAC;SACjB;QAED,OAAO,IAAI,CAAC;KACb;IAED,OAAO,IAAI,CAAC;AACd,CAAC;;SCnBe,WAAW,CAAC,QAAiB;IAC3C,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,QAAQ,CAAC;QAAE,OAAO,IAAI,CAAC;IAC1C,OAAO,QAAQ,CAAC,MAAM,CAAC,gBAAgB,CAAC,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;AACvD,CAAC;;ACHD,MAAM,WAAW,GAAG,MAAM,CAAC,MAAM,CAACA,sBAAc,CAAC,CAAC;AAElD,AAAO,MAAM,WAAW,GAAG,CAAC,SAAkB,KAC5C,OAAO,SAAS,KAAK,QAAQ,IAAI,WAAW,CAAC,QAAQ,CAAC,SAA2B,CAAC,CAAC;;SCFrE,SAAS,CAAC,QAAwB;IAChD,IAAI,YAAY,IAAI,QAAQ,IAAI,sBAAsB,IAAI,QAAQ,IAAI,mBAAmB,IAAI,QAAQ,EAAE;QACrG,OAAOA,sBAAc,CAAC,MAAM,CAAC;KAC9B;IAED,IAAI,OAAO,IAAI,QAAQ,IAAI,iBAAiB,IAAI,QAAQ,EAAE;QACxD,OAAOA,sBAAc,CAAC,KAAK,CAAC;KAC7B;IAED,OAAO,IAAI,CAAC;AACd,CAAC;;SCRe,QAAQ,CAAC,QAAwB;IAC/C,IAAI,MAAM,IAAI,QAAQ,EAAE;QACtB,IAAI,KAAK,CAAC,OAAO,CAAC,QAAQ,CAAC,IAAI,CAAC,EAAE;YAChC,OAAO,QAAQ,CAAC,IAAI,CAAC,MAAM,CAAC,WAAW,CAAC,CAAC;SAC1C;aAAM,IAAI,WAAW,CAAC,QAAQ,CAAC,IAAI,CAAC,EAAE;YACrC,OAAO,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;SACxB;KACF;IAED,MAAM,YAAY,GAAG,SAAS,CAAC,QAAQ,CAAC,CAAC;IACzC,IAAI,YAAY,KAAK,IAAI,EAAE;QACzB,OAAO,CAAC,YAAY,CAAC,CAAC;KACvB;IAED,OAAO,IAAI,CAAC;AACd,CAAC;;ACdM,MAAM,uBAAuB,GAAa,CAAC,UAAU,EAAE,WAAW,EAAE,OAAO,CAAC,CAAC;AAEpF,MAAM,gBAAgB,GAAkE;IACtF,MAAM,EAAE,CAAC,WAAW,EAAE,WAAW,EAAE,SAAS,CAAC;IAC7C,MAAM,EAAE,CAAC,YAAY,EAAE,SAAS,EAAE,kBAAkB,EAAE,SAAS,EAAE,kBAAkB,CAAC;IACpF,IAAI,OAAO;QACT,OAAO,IAAI,CAAC,MAAM,CAAC;KACpB;IACD,MAAM,EAAE,CAAC,sBAAsB,EAAE,eAAe,EAAE,eAAe,CAAC;IAClE,KAAK,EAAE,CAAC,iBAAiB,EAAE,UAAU,EAAE,UAAU,EAAE,aAAa,CAAC;CAClE,CAAC;AAEF,SAAS,kBAAkB,CAAC,KAAuB;IACjD,IAAI,gBAAgB,GAAoC,IAAI,CAAC;IAE7D,KAAK,MAAM,IAAI,IAAI,KAAK,EAAE;QACxB,MAAM,KAAK,GAAG,gBAAgB,CAAC,IAAI,CAAC,CAAC;QACrC,IAAI,KAAK,KAAK,KAAK,CAAC,EAAE;YACpB,gBAAgB,aAAhB,gBAAgB,cAAhB,gBAAgB,IAAhB,gBAAgB,GAAK,EAAE,EAAC;YACxB,gBAAgB,CAAC,IAAI,CAAC,GAAG,KAAK,CAAC,CAAC;SACjC;KACF;IAED,OAAO,gBAAgB,CAAC;AAC1B,CAAC;AAED,SAAgB,cAAc,CAAC,QAAwB,EAAE,KAA8B;IACrF,MAAM,gBAAgB,GAAG,KAAK,KAAK,IAAI,GAAG,IAAI,GAAG,kBAAkB,CAAC,KAAK,CAAC,CAAC;IAE3E,OAAO;QACL,GAAG,IAAI,CAAC,QAAQ,EAAE,uBAAuB,CAAC;QAC1C,IAAI,gBAAgB,KAAK,IAAI,GAAG,IAAI,CAAC,QAAQ,EAAE,gBAAgB,CAAC,GAAG,IAAI,CAAC;KACzE,CAAC;AACJ,CAAC;;SCrCe,YAAY,CAAC,QAAwB;IACnD,IAAI,cAAc,IAAI,QAAQ,EAAE;QAC9B,OAAO,QAAQ,CAAC,cAAc,CAAC,KAAK,IAAI,CAAC;KAC1C;IAED,IAAI,YAAY,IAAI,QAAQ,EAAE;QAC5B,OAAO,QAAQ,CAAC,UAAU,KAAK,IAAI,CAAC;KACrC;IAED,OAAO,KAAK,CAAC;AACf,CAAC;;MCGY,WAAY,SAAQ,QAAQ;IAkBvC,YAA4B,QAAwB,EAAE,OAA+C;;QACnG,KAAK,CAAC,QAAQ,CAAC,CAAC;QADU,aAAQ,GAAR,QAAQ,CAAgB;QAGlD,IAAI,CAAC,GAAG,GAAG,kBAAkB,CAAC,IAAI,IAAI,QAAQ,GAAG,QAAQ,CAAC,EAAE,GAAG,QAAQ,CAAC,GAAG,CAAC,CAAC;QAC7E,IAAI,CAAC,KAAK,GAAG,QAAQ,CAAC,QAAQ,CAAC,CAAC;QAChC,IAAI,CAAC,WAAW,GAAG,cAAc,CAAC,QAAQ,EAAE,IAAI,CAAC,KAAK,CAAC,CAAC;QACxD,IAAI,CAAC,SAAS,GAAG,YAAY,CAAC,QAAQ,CAAC,CAAC;QAExC,IAAI,CAAC,UAAU,GAAG,YAAY,CAAC,QAAQ,CAAC,CAAC;QACzC,IAAI,CAAC,IAAI,GAAG,OAAO,IAAI,QAAQ,GAAG,CAAC,QAAQ,CAAC,KAAK,CAAC,GAAG,iBAAiB,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;QACtF,IAAI,CAAC,QAAQ,GAAG,WAAW,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC;QAC/C,IAAI,CAAC,MAAM,GAAG,kBAAkB,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC;QAClD,IAAI,CAAC,KAAK,GAAG,kBAAkB,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;QAEhD,IAAI,CAAC,WAAW,GAAG,cAAc,CAAC,QAAQ,CAAC,CAAC;QAC5C,IAAI,CAAC,WAAW,GAAG,cAAc,CAAC,QAAQ,EAAE,IAAI,CAAC,KAAK,CAAC,CAAC;QACxD,IAAI,CAAC,gBAAgB,SAAG,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,gBAAgB,mCAAI,QAAQ,CAAC;QAE9D,IAAI,CAAC,QAAQ,GAAG,KAAK,CAAC,CAAC;KACxB;IAED,IAAW,MAAM;QACf,QACE,IAAI,CAAC,WAAW,KAAKA,sBAAc,CAAC,KAAK,IAAI,IAAI,CAAC,WAAW,KAAKA,sBAAc,CAAC,MAAM,IAAI,IAAI,CAAC,SAAS,KAAK,IAAI,EAClH;KACH;IAED,IAAW,OAAO;QAChB,QACE,IAAI,CAAC,KAAK,KAAK,IAAI;YACnB,IAAI,CAAC,SAAS,KAAK,IAAI;YACvB,IAAI,CAAC,MAAM,KAAK,IAAI;YACpB,IAAI,CAAC,IAAI,KAAK,IAAI;YAClB,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,MAAM,GAAG,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,MAAM,KAAK,CAAC,EACjF;KACH;CACF;;MCjEY,QAAS,SAAQ,QAAQ;IAIpC,YAA4B,QAAwB;QAClD,KAAK,CAAC,QAAQ,CAAC,CAAC;QADU,aAAQ,GAAR,QAAQ,CAAgB;QAHpC,WAAM,GAAG,IAAI,CAAC;QAK5B,IAAI,CAAC,QAAQ,GAAG,EAAE,CAAC;KACpB;CACF;;SCFe,YAAY,CAAC,IAAa;IACxC,MAAM,IAAI,GAAG,MAAM,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC,WAAW,CAAC,IAAI,CAAC;IAC1D,QACE,IAAI,KAAK,QAAQ,CAAC,IAAI;QACtB,IAAI,KAAK,WAAW,CAAC,IAAI;QACzB,IAAI,KAAK,mBAAmB,CAAC,IAAI;QACjC,IAAI,KAAK,aAAa,CAAC,IAAI;QAC3B,IAAI,KAAK,qBAAqB,CAAC,IAAI,EACnC;AACJ,CAAC;AAED,SAAgB,UAAU,CAAC,IAAgB;IACzC,OAAO,MAAM,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC,WAAW,CAAC,IAAI,KAAK,UAAU,CAAC;AACrE,CAAC;AAED,SAAgB,aAAa,CAAC,IAAgB;IAC5C,OAAO,OAAO,IAAI,IAAI,IAAI,aAAa,IAAI,IAAI,IAAI,WAAW,IAAI,IAAI,CAAC;AACzE,CAAC;AAED,SAAgB,cAAc,CAAC,IAAgB;IAC7C,OAAO,cAAc,IAAI,IAAI,CAAC;AAChC,CAAC;AAED,SAAgB,eAAe,CAAC,IAAgB;IAC9C,OAAO,UAAU,IAAI,IAAI,IAAI,OAAO,IAAI,IAAI,CAAC;AAC/C,CAAC;;MCnCY,cAAe,SAAQ,cAAc;IAAlD;;QACkB,SAAI,GAAG,gBAAgB,CAAC;KACzC;CAAA;AAED,MAAa,YAAa,SAAQ,KAAK;IAAvC;;QACkB,SAAI,GAAG,cAAc,CAAC;KACvC;CAAA;;ACAD,MAAM,YAAY,GAAG,OAAO,CAAC,oCAAoC,CAAC,CAAC;AAEnE,MAAM,KAAK,GAAG,IAAI,OAAO,EAAwD,CAAC;AAElF,SAAS,WAAW,CAAC,QAAwB,EAAE,IAAc,EAAE,UAAoC;IACjG,OAAO,YAAY,CAAC,QAAQ,EAAE;QAC5B,IAAI,EAAE,KAAK;QACX,SAAS,EAAE,YAAY,CAAC,kBAAkB;QAC1C,IAAI,UAAU,KAAK,IAAI;cACnB;gBACE,YAAY,CAAC,IAAa;oBACxB,IAAI,OAAO,IAAI,KAAK,QAAQ,EAAE;wBAC5B,OAAO,EAAE,CAAC;qBACX;oBAED,IAAIE,kBAAa,CAAC,IAAI,CAAC,CAAC,UAAU,CAAC,IAAI,CAAC,EAAE;wBACxC,MAAM,IAAI,cAAc,CAAC,6BAA6B,CAAC,CAAC;qBACzD;oBAED,MAAM,OAAO,GAAG,KAAK,CAAC,GAAG,CAAC,UAAU,CAAE,CAAC;oBACvC,IAAI,UAAU,GAAG,OAAO,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;oBAEvC,IAAI,UAAU,KAAK,KAAK,CAAC,EAAE;wBACzB,UAAU,GAAG,CAAC,IAAI,CAAC,CAAC;wBACpB,OAAO,CAAC,GAAG,CAAC,QAAQ,EAAE,UAAU,CAAC,CAAC;qBACnC;yBAAM,IAAI,UAAU,CAAC,QAAQ,CAAC,IAAI,CAAC,EAAE;wBACpC,MAAM,cAAc,GAAG,IAAI,CAAC,KAAK,CAACC,cAAS,CAAC,UAAU,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC,CAAC,CAAC;wBACrE,OAAO,OAAO,IAAI,cAAc,GAAG,WAAW,CAAC,cAAc,EAAE,IAAI,EAAE,UAAU,CAAC,GAAG,cAAc,CAAC;qBACnG;yBAAM;wBACL,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;qBACvB;oBAED,MAAM,QAAQ,GAAG,UAAU,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;oBAExC,IAAI,KAAK,CAAC,OAAO,CAAC,QAAQ,CAAC,KAAK,CAAC,EAAE;wBACjC,KAAK,MAAM,MAAM,IAAI,QAAQ,CAAC,KAAK,EAAE;4BACnC,MAAM,KAAK,GAAG,UAAU,CAAC,OAAO,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;4BAC9C,IAAI,OAAO,MAAM,CAAC,IAAI,KAAK,QAAQ,IAAI,KAAK,KAAK,CAAC,CAAC,IAAI,KAAK,KAAK,UAAU,CAAC,WAAW,CAAC,MAAM,CAAC,IAAI,CAAC,EAAE;gCACpG,MAAM,IAAI,cAAc,CAAC,6BAA6B,CAAC,CAAC;6BACzD;yBACF;qBACF;oBAED,OAAO,QAAQ,CAAC;iBACjB;aACF;cACD,IAAI,CAAC;KACV,CAAC,CAAC;AACL,CAAC;AAED,SAAgB,UAAU,CAAC,QAAwB,EAAE,IAAc,EAAE,cAA8B;IACjG,IAAI,cAAc,CAAC,UAAU,KAAK,IAAI,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,cAAc,CAAC,UAAU,CAAC,EAAE;QAC/E,KAAK,CAAC,GAAG,CAAC,cAAc,CAAC,UAAU,EAAE,IAAI,OAAO,EAAE,CAAC,CAAC;KACrD;IAED,MAAM,MAAM,GAAG,WAAW,CAAC,QAAQ,EAAE,IAAI,EAAE,cAAc,CAAC,UAAU,CAAC,CAAC;IACtE,IAAI,OAAO,IAAI,MAAM,EAAE;QACrB,OAAO,WAAW,CAAC,MAAM,EAAE,IAAI,EAAE,cAAc,CAAC,UAAU,CAAC,CAAC;KAC7D;IAED,OAAO,MAAM,CAAC;AAChB,CAAC;;SC9De,eAAe,CAC7B,QAAwB,EACxB,IAAc,EACd,cAA8B;IAE9B,MAAM,QAAQ,GAAGF,0BAAkB,CAAC,KAAK,IAAI,QAAQ,GAAGA,0BAAkB,CAAC,KAAK,GAAGA,0BAAkB,CAAC,KAAK,CAAC;IAC5G,MAAM,KAAK,GAAG,QAAQ,CAAC,QAAQ,CAAC,CAAC;IAEjC,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC;QAAE,OAAO,EAAE,CAAC;IAErC,MAAM,MAAM,GAAqB,EAAE,CAAC;IAEpC,IAAI,KAAK,CAAC,OAAO,CAAC,QAAQ,CAAC,KAAK,CAAC,IAAI,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE;QACzD,KAAK,MAAM,IAAI,IAAI,KAAK,EAAE;YACxB,MAAM,CAAC,IAAI,CAAC;gBACV,KAAK,EAAE,CAAC,GAAG,QAAQ,CAAC,KAAK,EAAE,IAAI,CAAC;aACjC,CAAC,CAAC;SACJ;QAED,OAAO,MAAM,CAAC;KACf;SAAM;QACL,KAAK,MAAM,IAAI,IAAI,KAAK,EAAE;YACxB,MAAM,YAAY,GAAG,EAAE,GAAG,QAAQ,EAAE,CAAC;YACrC,OAAO,YAAY,CAAC,QAAQ,CAAC,CAAC;YAE9B,IAAI,MAAM,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC,MAAM,KAAK,CAAC,EAAE;gBAC1C,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;aACnB;iBAAM;gBACL,MAAM,YAAY,GAChB,OAAO,IAAI,CAAC,IAAI,KAAK,QAAQ,IAAI,cAAc,CAAC,UAAU,KAAK,IAAI;sBAC/D,cAAc,CAAC,UAAU,CAAC,IAAI,EAAE,IAAI,CAAC,IAAI,CAAC;sBAC1C,IAAI,CAAC;gBACX,MAAM,YAAY,GAAG;oBACnB,KAAK,EAAE,CAAC,YAAY,EAAE,YAAY,CAAC;iBACpC,CAAC;gBAEF,IAAI;oBACF,MAAM,CAAC,IAAI,CAAC,UAAU,CAAC,YAAY,EAAE,IAAI,EAAE,cAAc,CAAC,CAAC,CAAC;iBAC7D;gBAAC,WAAM;oBACN,MAAM,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;iBAC3B;aACF;SACF;KACF;IAED,OAAO,MAAM,CAAC;AAChB,CAAC;;MC5BY,MAAO,SAAQG,sBAA2B;IAUrD,YAA+B,IAAc,EAAqB,cAA8B;QAC9F,KAAK,EAAE,CAAC;QADqB,SAAI,GAAJ,IAAI,CAAU;QAAqB,mBAAc,GAAd,cAAc,CAAgB;QAG9F,IAAI,CAAC,IAAI,GAAG,EAAE,CAAC;QACf,IAAI,CAAC,KAAK,GAAG,CAAC,CAAC,CAAC;QAChB,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC;QAC9B,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC;QACvB,IAAI,CAAC,kBAAkB,GAAG,IAAI,OAAO,EAA8B,CAAC;QAEpE,IAAI,CAAC,KAAK,GAAG,EAAE,CAAC;KACjB;IAEM,OAAO;QACZ,IAAI,CAAC,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC;QACrB,IAAI,CAAC,KAAK,GAAG,CAAC,CAAC,CAAC;QAChB,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC;QACnC,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC,IAAI,CAAC;QAC5B,IAAI,CAAC,kBAAkB,GAAG,IAAI,OAAO,EAA+C,CAAC;KACtF;IAEM,YAAY,CAAC,QAAwB;QAC1C,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,EAAE,IAAI,CAAC,IAAI,CAAC,MAAM,EAAE,GAAG,QAAQ,CAAC,IAAI,CAAC,CAAC;QACxD,IAAI,CAAC,KAAK,GAAG,QAAQ,CAAC,KAAK,CAAC;QAC5B,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC,QAAQ,CAAC;QAClC,IAAI,CAAC,UAAU,GAAG,QAAQ,CAAC,UAAU,CAAC;KACvC;IAEM,YAAY;QACjB,OAAO;YACL,KAAK,EAAE,IAAI,CAAC,KAAK;YACjB,QAAQ,EAAE,IAAI,CAAC,QAAQ;YACvB,UAAU,EAAE,IAAI,CAAC,UAAU;YAC3B,IAAI,EAAE,IAAI,CAAC,IAAI,CAAC,KAAK,EAAE;SACxB,CAAC;KACH;IAEM,QAAQ,CAAC,MAAwB,EAAE,OAA0B;QAClE,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,GAAG,OAAO,CAAC;KAC9B;IAEM,mBAAmB,CAAC,IAAiB;QAC1C,IAAI,CAAC,kBAAkB,CAAC,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;QAC9C,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,EAAE,IAAI,CAAC,IAAI,CAAC,MAAM,EAAE,GAAG,IAAI,CAAC,IAAI,CAAC,CAAC;QACpD,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC;QACxB,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC;QAC9B,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC;KACxB;IAEM,IAAI;;QACT,MAAM,EAAE,KAAK,EAAE,YAAY,EAAE,QAAQ,EAAE,GAAG,IAAI,CAAC;QAC/C,IAAI,EAAE,UAAU,EAAE,iBAAiB,EAAE,GAAG,IAAI,CAAC;QAE7C,IAAI,YAAY,KAAK,CAAC,CAAC,IAAI,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,MAAM,KAAK,CAAC,EAAE;YAE7D,OAAO;SACR;QAED,OAAO,cAAc,CAAC,iBAAiB,CAAC,EAAE;YACxC,IAAI,CAAC,aAAa,CAAC,iBAAiB,CAAC,YAAY,CAAC,EAAE;gBAClD,OAAO;aACR;YAED,IAAI,iBAAiB,CAAC,YAAY,CAAC,QAAQ,KAAK,KAAK,CAAC,EAAE;gBACtD,IAAI,CAAC,mBAAmB,CAAC,iBAAiB,CAAC,YAAY,CAAC,CAAC;gBACzD,iBAAiB,GAAG,IAAI,CAAC,UAAU,CAAC;gBACpC,IAAI,CAAC,KAAK,GAAG,YAAY,CAAC;aAC3B;iBAAM;gBACL,OAAO;aACR;SACF;QAED,MAAM,KAAK,GAAG,IAAI,CAAC,uBAAuB,EAAE,CAAC;QAE7C,KAAK,CAAC,IAAI,CAAC,eAAe,EAAE,QAAQ,CAAC,CAAC;QACtC,MAAM,CAAC,UAAU,EAAE,eAAe,CAAC,GAAG,IAAI,CAAC,eAAe,EAAE,CAAC;QAC7D,KAAK,CAAC,IAAI,CAAC,WAAW,EAAE,UAAU,CAAC,CAAC;QAEpC,MAAM,UAAU,GAAG,cAAc,CAAC,UAAU,CAAC,GAAG,UAAU,CAAC,YAAY,GAAG,UAAU,CAAC;QACrF,IAAI,CAAC,kBAAkB,CAAC,GAAG,CAAC,UAAU,CAAC,QAAQ,EAAE,UAAU,CAAC,CAAC;QAC7D,IAAI,CAAC,kBAAkB,CAAC,GAAG,CAAC,eAAe,EAAE,UAAU,CAAC,CAAC;QAEzD,IAAI,CAAC,QAAQ,GAAG,UAAU,CAAC,QAAQ,CAAC;QACpC,IAAI,CAAC,KAAK,GAAG,YAAY,GAAG,CAAC,CAAC;QAE9B,MAAM,UAAU,SAAG,MAAA,IAAI,CAAC,KAAK,EAAC,MAAM,mDAAG,UAAU,CAAC,CAAC;QAEnD,IAAI,UAAU,KAAK,KAAK,EAAE;YACxB,KAAK,CAAC,IAAI,CAAC,UAAU,EAAE,UAAU,CAAC,CAAC;YACnC,OAAO;SACR;QAED,IAAI,CAAC,UAAU,CAAC,UAAU,CAAC,EAAE;YAC3B,UAAU,CAAC,MAAM,GAAG,iBAAiB,CAAC;YACtC,UAAU,CAAC,OAAO,GAAG,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,iBAAiB,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;SACrE;QAED,IAAI,UAAU,IAAI,iBAAiB,IAAI,CAAC,UAAU,CAAC,UAAU,CAAC,EAAE;YAC9D,IAAI,iBAAiB,CAAC,QAAQ,KAAK,KAAK,CAAC,EAAE;gBACxC,iBAAiC,CAAC,QAAQ,GAAG,CAAC,UAAU,CAAC,CAAC;aAC5D;iBAAM;gBACL,iBAAiB,CAAC,QAAS,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;aAC9C;SACF;QAED,KAAK,CAAC,IAAI,CAAC,aAAa,EAAE,UAAU,CAAC,CAAC;QAEtC,IAAI,aAAa,CAAC,UAAU,CAAC,EAAE;YAC7B,IAAI,CAAC,UAAU,GAAG,UAAU,CAAC;YAE7B,IAAI,OAAA,MAAA,IAAI,CAAC,KAAK,EAAC,MAAM,mDAAG,UAAU,OAAM,KAAK,EAAE;gBAC7C,KAAK,CAAC,IAAI,CAAC,YAAY,EAAE,UAAU,CAAC,CAAC;gBACrC,IAAI,CAAC,gBAAgB,EAAE,CAAC;gBACxB,KAAK,CAAC,IAAI,CAAC,aAAa,EAAE,UAAU,CAAC,CAAC;aACvC;iBAAM;gBACL,KAAK,CAAC,IAAI,CAAC,cAAc,EAAE,UAAU,CAAC,CAAC;aACxC;SACF;QAED,KAAK,CAAC,IAAI,CAAC,UAAU,EAAE,UAAU,CAAC,CAAC;QACnC,IAAI,CAAC,0BAA0B,CAAC,KAAK,CAAC,CAAC;QACvC,KAAK,CAAC,IAAI,CAAC,cAAc,EAAE,QAAQ,CAAC,CAAC;KACtC;IAES,uBAAuB;QAC/B,OAAO;YACL,KAAK,EAAE,IAAI,CAAC,KAAK;YACjB,UAAU,EAAE,IAAI,CAAC,IAAI,CAAC,MAAM;YAC5B,UAAU,EAAE,IAAI,CAAC,UAAU;SAC5B,CAAC;KACH;IAES,0BAA0B,CAAC,EAAE,KAAK,EAAE,UAAU,EAAE,UAAU,EAAuB;QACzF,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;QACnB,IAAI,CAAC,IAAI,CAAC,MAAM,GAAG,UAAU,CAAC;QAC9B,IAAI,CAAC,UAAU,GAAG,UAAU,CAAC;KAC9B;IAES,gBAAgB;QACxB,MAAM,EAAE,QAAQ,EAAE,UAAU,EAAE,GAAG,IAAI,CAAC;QAEtC,IAAI,CAAC,aAAa,CAAC,UAAU,CAAC;YAAE,OAAO;QAEvC,MAAM,KAAK,GAAG,IAAI,CAAC,uBAAuB,EAAE,CAAC;QAE7C,IAAI,UAAU,CAAC,SAAS,KAAK,IAAI,EAAE;YACjC,KAAK,MAAM,QAAQ,IAAI,UAAU,CAAC,SAAS,EAAE;gBAC3C,MAAM,KAAK,GAAG,QAAQ,CAAC,QAAQ,CAAC,CAAC;gBACjC,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC;oBAAE,SAAS;gBAEpC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC;gBACX,KAAK,MAAM,IAAI,IAAI,KAAK,EAAE;oBACxB,CAAC,EAAE,CAAC;oBACJ,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC;wBAAE,SAAS;oBACrC,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC;oBACrB,IAAI,CAAC,0BAA0B,CAAC,KAAK,CAAC,CAAC;oBACvC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,QAAQ,EAAE,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;oBACpC,IAAI,CAAC,IAAI,EAAE,CAAC;iBACb;aACF;SACF;QAED,QAAQ,UAAU,CAAC,WAAW;YAC5B,KAAKJ,sBAAc,CAAC,KAAK;gBACvB,IAAI,KAAK,CAAC,OAAO,CAAC,QAAQ,CAAC,KAAK,CAAC,EAAE;oBACjC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC;oBACX,KAAK,MAAM,IAAI,IAAI,QAAQ,CAAC,KAAK,EAAE;wBACjC,CAAC,EAAE,CAAC;wBACJ,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC;4BAAE,SAAS;wBACrC,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC;wBACrB,IAAI,CAAC,0BAA0B,CAAC,KAAK,CAAC,CAAC;wBACvC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;wBACnC,IAAI,CAAC,IAAI,EAAE,CAAC;qBACb;iBACF;qBAAM,IAAI,eAAe,CAAC,QAAQ,CAAC,KAAK,CAAC,EAAE;oBAC1C,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC,KAAK,CAAC;oBAC/B,IAAI,CAAC,0BAA0B,CAAC,KAAK,CAAC,CAAC;oBACvC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;oBACxB,IAAI,CAAC,IAAI,EAAE,CAAC;iBACb;gBAED,MAAM;YACR,KAAKA,sBAAc,CAAC,MAAM;gBACxB,IAAI,eAAe,CAAC,QAAQ,CAAC,UAAU,CAAC,EAAE;oBACxC,KAAK,MAAM,GAAG,IAAI,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,EAAE;wBAClD,MAAM,KAAK,GAAG,QAAQ,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC;wBACvC,IAAI,CAAC,eAAe,CAAC,KAAK,CAAC;4BAAE,SAAS;wBACtC,IAAI,CAAC,QAAQ,GAAG,KAAK,CAAC;wBACtB,IAAI,CAAC,0BAA0B,CAAC,KAAK,CAAC,CAAC;wBACvC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,YAAY,EAAE,GAAG,CAAC,CAAC;wBAClC,IAAI,CAAC,IAAI,EAAE,CAAC;qBACb;iBACF;gBAED,IAAI,eAAe,CAAC,QAAQ,CAAC,iBAAiB,CAAC,EAAE;oBAC/C,KAAK,MAAM,GAAG,IAAI,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,iBAAiB,CAAC,EAAE;wBACzD,MAAM,KAAK,GAAG,QAAQ,CAAC,iBAAiB,CAAC,GAAG,CAAC,CAAC;wBAC9C,IAAI,CAAC,eAAe,CAAC,KAAK,CAAC;4BAAE,SAAS;wBACtC,IAAI,CAAC,QAAQ,GAAG,KAAK,CAAC;wBACtB,IAAI,CAAC,0BAA0B,CAAC,KAAK,CAAC,CAAC;wBACvC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,mBAAmB,EAAE,GAAG,CAAC,CAAC;wBACzC,IAAI,CAAC,IAAI,EAAE,CAAC;qBACb;iBACF;gBAED,MAAM;SACT;QAED,IAAI,CAAC,UAAU,GAAG,UAAU,CAAC;KAC9B;IAES,oBAAoB,CAC5B,QAA2B,EAC3B,gBAAgC;QAEhC,MAAM,mBAAmB,GAAG,IAAI,CAAC,kBAAkB,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;QAClE,IAAI,mBAAmB,KAAK,KAAK,CAAC,EAAE;YAClC,IAAI,aAAa,CAAC,mBAAmB,CAAC,EAAE;gBACtC,OAAO,CAAC,IAAI,mBAAmB,CAAC,mBAAmB,EAAE,EAAE,gBAAgB,EAAE,CAAC,EAAE,QAAQ,CAAC,CAAC;aACvF;YAED,IAAI,eAAe,CAAC,mBAAmB,CAAC,EAAE;gBACxC,OAAO,CAAC,IAAI,qBAAqB,CAAC,mBAAmB,CAAC,EAAE,QAAQ,CAAC,CAAC;aACnE;YAGD,MAAM,IAAI,SAAS,CAAC,wBAAwB,CAAC,CAAC;SAC/C;KACF;IAES,eAAe;;QACvB,MAAM,EAAE,cAAc,EAAE,IAAI,EAAE,QAAQ,EAAE,gBAAgB,EAAE,GAAG,IAAI,CAAC;QAClE,IAAI,EAAE,QAAQ,EAAE,GAAG,IAAI,CAAC;QAExB,IAAI,SAAS,GAAG,aAAa,CAAC,QAAQ,CAAC,GAAG,IAAI,CAAC,oBAAoB,CAAC,QAAQ,EAAE,gBAAgB,CAAC,GAAG,IAAI,CAAC;QAEvG,IAAI,SAAS,EAAE;YACb,OAAO,SAAS,CAAC;SAClB;QAED,IAAI,MAAM,IAAI,QAAQ,EAAE;YACtB,IAAI,OAAO,QAAQ,CAAC,IAAI,KAAK,QAAQ,EAAE;gBACrC,OAAO,CAAC,IAAI,aAAa,CAAC,QAAQ,EAAE,sBAAsB,CAAC,EAAE,QAAQ,CAAC,CAAC;aACxE;iBAAM,IAAI,cAAc,CAAC,UAAU,KAAK,IAAI,EAAE;gBAC7C,IAAI;oBACF,QAAQ,GAAG,cAAc,CAAC,UAAU,CAAC,IAAI,EAAE,QAAQ,CAAC,IAAI,CAAC,CAAC;iBAC3D;gBAAC,OAAO,EAAE,EAAE;oBACX,KAAK,CAAC,IAAI,CAAC,OAAO,EAAE,gBAAgB,CAAC,EAAE,CAAC,CAAC,CAAC;oBAC1C,OAAO,CAAC,IAAI,aAAa,CAAC,QAAQ,QAAE,EAAE,aAAF,EAAE,uBAAF,EAAE,CAAE,OAAO,mCAAI,yBAAyB,CAAC,EAAE,QAAQ,CAAC,CAAC;iBAC1F;aACF;iBAAM;gBACL,OAAO,CAAC,IAAI,aAAa,CAAC,QAAQ,EAAE,IAAI,CAAC,EAAE,QAAQ,CAAC,CAAC;aACtD;SACF;QAED,IAAI,eAAe,GAAsB,QAAQ,CAAC;QAClD,IAAI,cAAc,CAAC,UAAU,IAAIC,0BAAkB,CAAC,KAAK,IAAI,QAAQ,EAAE;YACrE,IAAI;gBACF,IAAI,KAAK,CAAC,OAAO,CAAC,QAAQ,CAAC,KAAK,CAAC,EAAE;oBACjC,eAAe,GAAG,QAAQ,CAAC,KAAK,CAAC;iBAClC;gBAED,QAAQ,GAAG,UAAU,CAAC,QAAQ,EAAE,IAAI,EAAE,cAAc,CAAC,CAAC;aACvD;YAAC,OAAO,EAAE,EAAE;gBACX,eAAe,GAAG,QAAQ,CAAC;gBAC3B,KAAK,CAAC,IAAI,CAAC,OAAO,EAAE,gBAAgB,CAAC,IAAI,YAAY,OAAC,EAAE,aAAF,EAAE,uBAAF,EAAE,CAAE,OAAO,mCAAI,uBAAuB,CAAC,CAAC,CAAC,CAAC;aAEjG;SACF;QAED,IAAIA,0BAAkB,CAAC,KAAK,IAAI,QAAQ,IAAIA,0BAAkB,CAAC,KAAK,IAAI,QAAQ,EAAE;YAChF,IAAI;gBACF,MAAM,MAAM,GAAG,eAAe,CAAC,QAAQ,EAAE,IAAI,EAAE,cAAc,CAAC,CAAC;gBAC/D,IAAI,MAAM,CAAC,MAAM,KAAK,CAAC,EAAE;oBACvB,OAAO,CAAC,IAAI,WAAW,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,EAAE,gBAAgB,EAAE,CAAC,EAAE,eAAe,CAAC,CAAC;iBAC5E;qBAAM;oBACL,MAAM,QAAQ,GAAGA,0BAAkB,CAAC,KAAK,IAAI,QAAQ,GAAGA,0BAAkB,CAAC,KAAK,GAAGA,0BAAkB,CAAC,KAAK,CAAC;oBAC5G,OAAO,CAAC,IAAI,WAAW,CAAC,EAAE,CAAC,QAAQ,GAAG,MAAM,EAAE,EAAE,EAAE,gBAAgB,EAAE,CAAC,EAAE,eAAe,CAAC,CAAC;iBACzF;aACF;YAAC,OAAO,EAAE,EAAE;gBACX,KAAK,CAAC,IAAI,CAAC,OAAO,EAAE,gBAAgB,CAAC,IAAI,YAAY,OAAC,EAAE,aAAF,EAAE,uBAAF,EAAE,CAAE,OAAO,mCAAI,uBAAuB,CAAC,CAAC,CAAC,CAAC;aAEjG;SACF;QAED,SAAS,GAAG,aAAa,CAAC,QAAQ,CAAC,GAAG,IAAI,CAAC,oBAAoB,CAAC,eAAe,EAAE,gBAAgB,CAAC,GAAG,IAAI,CAAC;QAE1G,IAAI,SAAS,EAAE;YACb,OAAO,SAAS,CAAC;SAClB;QAED,OAAO,CAAC,IAAI,WAAW,CAAC,QAAQ,EAAE,EAAE,gBAAgB,EAAE,CAAC,EAAE,eAAe,CAAC,CAAC;KAC3E;CACF;;MC3TY,UAAU;IAIrB,YAAmB,MAAsB,EAAqB,IAAiC;;QAA5E,WAAM,GAAN,MAAM,CAAgB;QAAqB,SAAI,GAAJ,IAAI,CAA6B;QAqBrF,eAAU,GAAsB,CAAC,IAAI,EAAE,IAAI;YACnD,MAAM,QAAQ,GAAa,EAAE,CAAC;YAC9B,IAAI,OAAO,GAAY,IAAI,CAAC;YAC5B,IAAI,aAA8B,CAAC;YAEnC,OAAO,OAAO,OAAO,KAAK,QAAQ,EAAE;gBAClC,IAAI,QAAQ,CAAC,QAAQ,CAAC,OAAO,CAAC,EAAE;oBAC9B,MAAM;iBACP;gBAED,QAAQ,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;gBACvB,aAAa,GAAG,IAAI,CAAC,WAAW,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;gBAChD,OAAO,GAAG,aAAa,CAAC,IAAI,CAAC;aAC9B;YAED,OAAO,aAAa,CAAC;SACtB,CAAC;QAEM,gBAAW,GAAsB,CAAC,IAAI,EAAE,IAAI;;YAClD,MAAM,MAAM,GAAGI,yBAAoB,CAAC,IAAI,CAAC,CAAC;YAC1C,MAAM,OAAO,GAAGC,0BAAqB,CAAC,IAAI,CAAC,CAAC;YAC5C,MAAM,WAAW,SAAG,IAAI,CAAC,IAAI,0CAAE,WAAW,CAAC;YAE3C,IAAI,OAAO,WAAW,KAAK,UAAU,EAAE;gBACrC,OAAO,WAAW,CAAC,EAAE,MAAM,EAAE,OAAO,EAAE,EAAE,IAAI,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC;aAC5D;iBAAM,IAAI,MAAM,KAAK,IAAI,EAAE;gBAC1B,MAAM,IAAI,cAAc,CAAC,wCAAwC,CAAC,CAAC;aACpE;iBAAM,IAAI,OAAO,KAAK,IAAI,EAAE;gBAC3B,MAAM,IAAI,cAAc,CAAC,sBAAsB,CAAC,CAAC;aAClD;iBAAM,IAAI,eAAe,CAAC,IAAI,CAAC,MAAM,CAAC,EAAE;gBACvC,MAAM,KAAK,GAAGC,qBAAgB,CAAC,IAAI,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC;gBACrD,IAAI,CAAC,eAAe,CAAC,KAAK,CAAC,EAAE;oBAC3B,MAAM,IAAI,cAAc,CAAC,eAAe,CAAC,CAAC;iBAC3C;gBAED,OAAO,KAAK,CAAC;aACd;iBAAM;gBACL,MAAM,IAAI,cAAc,CAAC,kBAAkB,CAAC,CAAC;aAC9C;SACF,CAAC;QA3DA,IAAI,CAAC,IAAI,GAAG,IAAI,QAAQ,CAAC,MAAM,CAAC,CAAC;QACjC,IAAI,CAAC,MAAM,GAAG,IAAI,MAAM,CAAC,IAAI,CAAC,IAAI,EAAE;YAClC,UAAU,EAAE,OAAA,IAAI,CAAC,IAAI,0CAAE,UAAU,MAAK,KAAK;YAC3C,UAAU,EAAE,CAAA,IAAI,aAAJ,IAAI,uBAAJ,IAAI,CAAE,WAAW,MAAK,IAAI,GAAG,IAAI,GAAG,IAAI,CAAC,UAAU;SAChE,CAAC,CAAC;KACJ;IAEM,OAAO;QACZ,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,MAAM,GAAG,CAAC,CAAC;QAC9B,IAAI,CAAC,MAAM,CAAC,OAAO,EAAE,CAAC;KACvB;IAEM,QAAQ;QACb,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;KAChC;IAEM,YAAY,CAAC,MAAc;QAChC,MAAM,CAAC,IAAI,EAAE,CAAC;KACf;CA0CF;;;;;;;;;;;;;;;"}